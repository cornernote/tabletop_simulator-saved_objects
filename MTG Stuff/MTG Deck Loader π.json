{
  "SaveName": "",
  "Date": "",
  "VersionNumber": "",
  "GameMode": "",
  "GameType": "",
  "GameComplexity": "",
  "Tags": [],
  "Gravity": 0.5,
  "PlayArea": 0.5,
  "Table": "",
  "Sky": "",
  "Note": "",
  "TabStates": {},
  "LuaScript": "",
  "LuaScriptState": "",
  "XmlUI": "",
  "ObjectStates": [
    {
      "GUID": "de46d2",
      "Name": "Custom_Token",
      "Transform": {
        "posX": -26.085,
        "posY": 1.01997066,
        "posZ": -14.3100014,
        "rotX": 9.59237E-05,
        "rotY": 180.0,
        "rotZ": -0.000246820535,
        "scaleX": 3.5,
        "scaleY": 1.0,
        "scaleZ": 3.5
      },
      "Nickname": "MTG Deck Loader [i]π[/i]",
      "Description": "Enter your deck URL from many online deck builders!\n\nYou can also paste a decklist in MTG Arena format into your color's notebook.\n\nCurrently supported sites:\n - archidekt.com\n - deckstats.net\n - frogtown.me\n - moxfield.com\n - mtggoldfish.com\n - tappedout.net\n - scryfall.com",
      "GMNotes": "",
      "Memo": "r@^@YPKgRL]QEZI`ZCDXPAVA\u0013KTWT\u0003Z\u0004\u0006\u001a\tW\u0006",
      "AltLookAngle": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
      },
      "ColorDiffuse": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": false,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "CustomImage": {
        "ImageURL": "https://steamusercontent-a.akamaihd.net/ugc/1771582194473171045/ED5F0E74B7222D58A8A1CA9CDD6E1D0A1EC9A52D/",
        "ImageSecondaryURL": "",
        "ImageScalar": 1.0,
        "WidthScale": 0.0,
        "CustomToken": {
          "Thickness": 0.1,
          "MergeDistancePixels": 25.0,
          "StandUp": false,
          "Stackable": false
        }
      },
      "LuaScript": "-- this thingy has been modified by π for his table\r\n-- if you take it and try to use it AS-IS it might not work and break other stuff on your table\r\n-- get the vanilla version from the original un-modified mod here, by Omes:\r\n-- https://steamcommunity.com/sharedfiles/filedetails/?id=2163084841\r\n-- if you do take my modified version, please let me know\r\n\r\n------ CONSTANTS\r\nTAPPEDOUT_BASE_URL = \"https://tappedout.net/mtg-decks/\"\r\nTAPPEDOUT_URL_SUFFIX = \"/\"\r\nTAPPEDOUT_URL_MATCH = \"tappedout%.net\"\r\n\r\nARCHIDEKT_BASE_URL = \"https://archidekt.com/api/decks/\"\r\nARCHIDEKT_URL_SUFFIX = \"/\"\r\nARCHIDEKT_URL_MATCH = \"archidekt%.com\"\r\n\r\nGOLDFISH_BASE_URL = 'https://www.mtggoldfish.com/deck/arena_download/'\r\nGOLDFISH_URL_SUFFIX = '/'\r\nGOLDFISH_URL_MATCH = \"mtggoldfish%.com\"\r\n\r\nMOXFIELD_BASE_URL = \"https://api2.moxfield.com/v3/decks/all/\"\r\nMOXFIELD_URL_SUFFIX = \"/\"\r\nMOXFIELD_URL_MATCH = \"moxfield%.com\"\r\n\r\nDECKSTATS_URL_SUFFIX = \"?include_comments=1&export_mtgarena=1\"\r\nDECKSTATS_URL_MATCH = \"deckstats%.net\"\r\n\r\nSCRYFALL_URL_MATCH = \"scryfall%.com\"\r\n\r\nSCRYFALL_ID_BASE_URL = \"https://api.scryfall.com/cards/\"\r\nSCRYFALL_MULTIVERSE_BASE_URL = \"https://api.scryfall.com/cards/multiverse/\"\r\nSCRYFALL_SET_NUM_BASE_URL = \"https://api.scryfall.com/cards/\"\r\nSCRYFALL_SEARCH_BASE_URL = \"https://api.scryfall.com/cards/search/?q=\"\r\nSCRYFALL_NAME_BASE_URL = \"https://api.scryfall.com/cards/named/?exact=\"\r\n\r\nDECK_SOURCE_URL = \"url\"\r\nDECK_SOURCE_NOTEBOOK = \"notebook\"\r\n\r\nMAINDECK_POSITION_OFFSET = {0.0, 1, 0.1286}\r\nDOUBLEFACE_POSITION_OFFSET = {1.47, 1, 0.1286}\r\nSIDEBOARD_POSITION_OFFSET = {-1.47, 1, 0.1286}\r\nCOMMANDER_POSITION_OFFSET = {0.7286, 1, -0.8257}\r\nTOKENS_POSITION_OFFSET = {-0.7286, 1, -0.8257}\r\n\r\n-- pieHere, swapped for \"my\" cardBack\r\nDEFAULT_CARDBACK = \"https://steamusercontent-a.akamaihd.net/ugc/1647720103762682461/35EF6E87970E2A5D6581E7D96A99F8A575B7A15F/\"\r\nDEFAULT_LANGUAGE = \"en\"\r\n\r\nDEFAULT_QUALITY = \"large\"\r\n\r\nLANGUAGES = {\r\n    [\"en\"] = \"en\",\r\n    [\"es\"] = \"es\",\r\n    [\"sp\"] = \"sp\",\r\n    [\"fr\"] = \"fr\",\r\n    [\"de\"] = \"de\",\r\n    [\"it\"] = \"it\",\r\n    [\"pt\"] = \"pt\",\r\n    [\"ja\"] = \"ja\",\r\n    [\"jp\"] = \"ja\",\r\n    [\"ko\"] = \"ko\",\r\n    [\"kr\"] = \"ko\",\r\n    [\"ru\"] = \"ru\",\r\n    [\"zhs\"] = \"zhs\",\r\n    [\"cs\"] = \"zcs\",\r\n    [\"zht\"] = \"zht\",\r\n    [\"ph\"] = \"ph\",\r\n    [\"english\"] = \"en\",\r\n    [\"spanish\"] = \"es\",\r\n    [\"french\"] = \"fr\",\r\n    [\"german\"] = \"de\",\r\n    [\"italian\"] = \"it\",\r\n    [\"portugese\"] = \"pt\",\r\n    [\"japanese\"] = \"ja\",\r\n    [\"korean\"] = \"ko\",\r\n    [\"russian\"] = \"ru\",\r\n    [\"chinese\"] = \"zhs\",\r\n    [\"simplified chinese\"] = \"zhs\",\r\n    [\"traditional chinese\"] = \"zht\",\r\n    [\"phyrexian\"] = \"ph\"\r\n}\r\n\r\n------ UI IDs\r\nUI_ADVANCED_PANEL = \"MTGDeckLoaderAdvancedPanel\"\r\nUI_CARD_BACK_INPUT = \"MTGDeckLoaderCardBackInput\"\r\nUI_LANGUAGE_INPUT = \"MTGDeckLoaderLanguageInput\"\r\nUI_FORCE_LANGUAGE_TOGGLE = \"MTGDeckLoaderForceLanguageToggleID\"\r\nUI_COMBINE_DFC = \"MTGDeckLoaderDFCStateToggleID\"\r\n\r\n------ GLOBAL STATE\r\nlock = false\r\nplayerColor = nil\r\ndeckSource = nil\r\nadvanced = false\r\ncardBackInput = \"\"\r\nlanguageInput = \"\"\r\nforceLanguage = false\r\ncombineStates = true\r\ncardTokenDat = true\r\n\r\n------ UTILITY\r\nlocal function trim(s)\r\n    if not s then return \"\" end\r\n\r\n    local n = s:find\"%S\"\r\n    return n and s:match(\".*%S\", n) or \"\"\r\nend\r\n\r\nlocal function iterateLines(s)\r\n    if not s or string.len(s) == 0 then\r\n        return ipairs({})\r\n    end\r\n\r\n    if s:sub(-1) ~= '\\n' then\r\n        s = s .. '\\n'\r\n    end\r\n\r\n    local pos = 1\r\n    return function ()\r\n        if not pos then return nil end\r\n\r\n        local p1, p2 = s:find(\"\\r?\\n\", pos)\r\n\r\n        local line\r\n        if p1 then\r\n            line = s:sub(pos, p1 - 1)\r\n            pos = p2 + 1\r\n        else\r\n            line = s:sub(pos)\r\n            pos = nil\r\n        end\r\n\r\n        return line\r\n    end\r\nend\r\n\r\nlocal function underline(s)\r\n    if not s or string.len(s) == 0 then\r\n        return \"\"\r\n    end\r\n\r\n    return s .. '\\n' .. string.rep('-', string.len(s)) .. '\\n'\r\nend\r\n\r\nlocal function shallowCopyTable(t)\r\n    if type(t) == 'table' then\r\n        local copy = {}\r\n        for key, val in pairs(t) do\r\n            copy[key] = val\r\n        end\r\n\r\n        return copy\r\n    end\r\n\r\n    return {}\r\nend\r\n\r\nlocal function readNotebookForColor(playerColor)\r\n    for i, tab in ipairs(Notes.getNotebookTabs()) do\r\n        if tab.title == playerColor and tab.color == playerColor then\r\n            return tab.body\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\nlocal function vecSum(v1, v2)\r\n    return {v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]}\r\nend\r\n\r\nlocal function vecMult(v, s)\r\n    return {v[1] * s, v[2] * s, v[3] * s}\r\nend\r\n\r\nlocal function valInTable(table, v)\r\n    for _, value in ipairs(table) do\r\n        if value == v then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nlocal function printErr(s)\r\n    printToColor(s, playerColor, {r=1, g=0, b=0})\r\nend\r\n\r\nlocal function printInfo(s)\r\n    printToColor(s, playerColor)\r\nend\r\n\r\n------ CARD SPAWNING\r\n\r\n-- Spawns a deck named [name] containing the given [cards] at [position].\r\n-- Deck will be face down if [flipped].\r\n-- Calls [onFullySpawned] when the object is spawned.\r\nlocal function spawnDeck(cards, name, position, flipped, onFullySpawned, onError)\r\n\r\n    local rotation\r\n    if flipped then\r\n        rotation = vecSum(self.getRotation(), {0, 0, 180})\r\n    else\r\n        rotation = self.getRotation()\r\n    end\r\n\r\n    local cardObjects = {}\r\n    local sem = 0\r\n    local function incSem() sem = sem + 1 end\r\n    local function decSem() sem = sem - 1 end\r\n\r\n    local n=0\r\n    for _, card in ipairs(cards) do\r\n        for i=1,(card.count or 1) do\r\n            if not card.faces or not card.faces[1] then\r\n                card.faces = {{\r\n                    name = card.name,\r\n                    oracleText = \"Card not found\",\r\n                    imageURI = \"https://vignette.wikia.nocookie.net/yugioh/images/9/94/Back-Anime-2.png/revision/latest?cb=20110624090942\",\r\n                }}\r\n            end\r\n            incSem()\r\n            n=n+1\r\n            local cardDat={\r\n              Transform={posX=0,posY=0,posZ=0,rotX=0,rotY=0,rotZ=0,scaleX=1,scaleY=1,scaleZ=1},\r\n              Name=\"Card\",\r\n              Nickname=card.faces[1].name,\r\n              Description=card.faces[1].oracleText,\r\n              Memo=card.oracleID,\r\n              CardID=n*100,\r\n              CustomDeck={[n]={FaceURL=card.faces[1].imageURI,BackURL=getCardBack(),NumWidth=1,NumHeight=1,Type=0,BackIsHidden=true,UniqueBack=false}},\r\n              LuaScriptState=card.all_parts_json,\r\n              LuaScript=card.all_parts_json=='' and '' or cardScript\r\n            }\r\n\r\n            local type_line = card.faces[1].name:match(\"\\n(.*)\\n\")\r\n            if type_line:match('[Bb]attle') then\r\n              cardDat.AltLookAngle={0,180,270}\r\n            end\r\n\r\n            if card.faces[2] then\r\n              n=n+1\r\n              local backDat={\r\n                Transform={posX=0,posY=0,posZ=0,rotX=0,rotY=0,rotZ=0,scaleX=1,scaleY=1,scaleZ=1},\r\n                Name=\"Card\",\r\n                Nickname=card.faces[2].name,\r\n                Description=card.faces[2].oracleText,\r\n                Memo=card.oracleID,\r\n                CardID=n*100,\r\n                CustomDeck={[n]={FaceURL=card.faces[2].imageURI,BackURL=getCardBack(),NumWidth=1,NumHeight=1,Type=0,BackIsHidden=true,UniqueBack=false}},\r\n                LuaScriptState=card.all_parts_json,\r\n                LuaScript=card.all_parts_json=='' and '' or cardScript\r\n              }\r\n              if combineStates then    -- set card state\r\n                cardDat.States={[2]=backDat}\r\n                table.insert(cardObjects,cardDat)\r\n              else\r\n                table.insert(cardObjects,cardDat)\r\n                table.insert(cardObjects,backDat)\r\n              end\r\n            else\r\n              table.insert(cardObjects,cardDat)\r\n            end\r\n            decSem()\r\n        end\r\n    end\r\n\r\n    if #cardObjects==1 then\r\n        spawnDat={\r\n            data = cardObjects[1],\r\n            position = position,\r\n            rotation = rotation,\r\n        }\r\n        spawnObjectData(spawnDat)\r\n    elseif #cardObjects>1 then\r\n        local deckDat={\r\n            Transform={posX=0,posY=0,posZ=0,rotX=0,rotY=0,rotZ=0,scaleX=1,scaleY=1,scaleZ=1},\r\n            Name=\"Deck\",\r\n            Nickname=name,\r\n            Description=\"\",\r\n            DeckIDs={},\r\n            CustomDeck={},\r\n            ContainedObjects={},\r\n        }\r\n        for i,cardDat in ipairs(cardObjects) do\r\n            local n=cardDat.CardID/100\r\n            deckDat.DeckIDs[i]=cardDat.CardID\r\n            deckDat.CustomDeck[n]=cardDat.CustomDeck[n]\r\n            deckDat.ContainedObjects[i]=cardDat\r\n        end\r\n        spawnDat={\r\n            data = deckDat,\r\n            position = position,\r\n            rotation = rotation,\r\n        }\r\n        deckObject=spawnObjectData(spawnDat)\r\n    end\r\n    onFullySpawned(deckObject)\r\n\r\nend\r\n\r\n------ SCRYFALL\r\nlocal function stripScryfallImageURI(uri)\r\n    if not uri or string.len(uri) == 0 then\r\n        return \"\"\r\n    end\r\n\r\n    return uri:match(\"(.*)%?\") or \"\"\r\nend\r\n\r\n-- Returns a nicely formatted card name with type_line and cmc\r\nlocal function getAugmentedName(cardData,i)\r\n\r\n    local cmc = cardData.cmc\r\n\r\n    if not cardData.cmc and cardData.card_faces[1].cmc then\r\n      cmc = cardData.card_faces[1].cmc\r\n    end\r\n\r\n    if i then\r\n      cardData=cardData.card_faces[i]\r\n    end\r\n\r\n    local name = cardData.name:gsub('\"', '') or \"\"\r\n    local type_line = cardData.type_line\r\n\r\n    if not cardData.type_line then\r\n      type_line = cardData.card_faces[1].type_line\r\n    end\r\n\r\n    name = name .. '\\n' .. type_line\r\n    name = name .. '\\n' .. cmc .. ' CMC'\r\n\r\n    return name\r\nend\r\n\r\n-- Returns a nicely formatted oracle text with power/toughness or loyalty\r\n-- if present\r\nlocal function getAugmentedOracleText(cardData,i)\r\n    local oracleText = cardData.oracle_text\r\n\r\n    if cardData.power and cardData.toughness then\r\n        oracleText = oracleText .. '\\n[b]' .. cardData.power .. '/' .. cardData.toughness .. '[/b]'\r\n    elseif cardData.loyalty then\r\n        oracleText = oracleText .. '\\n[b]' .. tostring(cardData.loyalty) .. '[/b]'\r\n    elseif cardData.defense then\r\n        oracleText = oracleText .. '\\n[b]' .. tostring(cardData.defense) .. '[/b]'\r\n    end\r\n\r\n    return oracleText\r\nend\r\n\r\n-- Collects oracle text from multiple faces if present\r\nlocal function collectOracleText(cardData,ii)\r\n    local oracleText = \"\"\r\n\r\n    if cardData.card_faces then\r\n        if ii then\r\n            oracleText = getAugmentedOracleText(cardData.card_faces[ii])\r\n        else\r\n            for i, face in ipairs(cardData.card_faces) do\r\n                oracleText = oracleText .. underline(face.name) .. getAugmentedOracleText(face)\r\n\r\n                if i < #cardData.card_faces then\r\n                    oracleText = oracleText .. '\\n\\n'\r\n                end\r\n            end\r\n        end\r\n    else\r\n        oracleText = getAugmentedOracleText(cardData)\r\n    end\r\n\r\n    return oracleText\r\nend\r\n\r\n\r\nfunction parseForToken(oracle)\r\n\r\n  oracle=oracle:lower()\r\n  oracle=oracle:gsub(' and ',' ')     -- easier parsing without this\r\n  oracle=oracle:gsub('%.\"','\".')      -- move periods outside of quotes\r\n\r\n  local token_uris={}\r\n  local nSpawned=0\r\n\r\n  if not((oracle:find('create') and oracle:find(' token')) or oracle:find(' emblem')) then\r\n    return token_uris\r\n  end\r\n\r\n  ------------------------------------------------------------------------------\r\n  -- emblem parsing\r\n  local in1=oracle:find('emblem with \"')\r\n  if in1~=nil then\r\n    in1=in1+12\r\n    in2=oracle:find('\"',in1+1)\r\n    local eOracle=oracle:sub(in1,in2)\r\n    nSpawned=nSpawned+1\r\n    table.insert(token_uris,'https://api.scryfall.com/cards/search?q=t:emblem+oracle:'..eOracle)\r\n  end\r\n\r\n  ------------------------------------------------------------------------------\r\n  -- token parsing\r\n\r\n  -- indoracle: processed oracle text to look for indexes, start and end of token description chunk\r\n  local indoracle=oracle\r\n\r\n  while indoracle:find('\"') do            -- 1. blank out text within quotes\r\n    i1=indoracle:find('\"')\r\n    i2=indoracle:find('\"',i1+1)\r\n    indoracle=indoracle:sub(1,i1-1)\r\n    for i=i1,i2 do\r\n      indoracle=indoracle..'_'\r\n    end\r\n    indoracle=indoracle..oracle:sub(i2+1,-1)\r\n  end\r\n  indoracle:gsub('. it has','  it has')   -- 2. combine sentences if a sentence starts with \"It has\"\r\n\r\n\r\n  local ind1,ind2,ind3=nil,nil,0\r\n  ind3=indoracle:find('create[sd]?')      -- 'create' must appear first\r\n  -- the following words always start (or end) a token description chunk\r\n  local startWords={'create[sd]?','that many','or more','tapped','a number of','a','an','twice','x',\r\n                  'one','two','three','four','five','six','seven','eight','nine','ten'}\r\n  local keepParsing=true\r\n\r\n  while keepParsing do\r\n\r\n    ind1=nil\r\n    ind2=indoracle:find('token',ind3)   -- find 'token'\r\n    if ind2 then\r\n      ind1=ind3                         -- start of chunk is the end of the previous one\r\n      ind3=indoracle:find('%.',ind2)    -- default end of chunk is a period\r\n\r\n      local rind1=indoracle:len()-ind1+1    --reverse string ind1\r\n      local rind2=indoracle:len()-ind2+1    --reverse string ind2\r\n\r\n      for _,word in ipairs(startWords) do\r\n\r\n        -- ind1: look for a starting word, searching *back* from 'token'\r\n        local r1=indoracle:reverse():find(' '..word:reverse()..' ',rind2)\r\n        if r1 and r1<rind1 then\r\n          rind1=r1\r\n          ind1=indoracle:len()-rind1+1\r\n          ind1=indoracle:find(' ',ind1)\r\n        end\r\n\r\n        -- ind2: look for a starting word, searching *forward* from 'token'\r\n        local i3=indoracle:find(' '..word..' ',ind2)\r\n        if i3 and i3<ind3 then\r\n          ind3=i3\r\n        end\r\n      end\r\n\r\n    end\r\n\r\n    if not(ind1 and ind2 and ind3) then\r\n      keepParsing=false\r\n    else\r\n\r\n      local searchStr='t:token+-is:dfc'   -- don't want dfc tokens\r\n      local foundType=false\r\n      local preToken = oracle:sub(ind1,ind2-1)\r\n      local postToken = oracle:sub(ind2,ind3)\r\n\r\n      -- remove any descriptive/count words in prefix, only want color,type and pow/tou\r\n      for _,div in pairs(startWords) do\r\n        preToken=preToken:gsub(' '..div..' ',' ')\r\n      end\r\n\r\n      -- are there colors listsed in prefix?\r\n      local colors=''\r\n      for k,v in pairs({w='white',u='blue',b='black',r='red',g='green',c='colorless'})do\r\n        if preToken:find(v)then\r\n          preToken=preToken:gsub(v,'')\r\n          colors=colors..k\r\n        end\r\n      end\r\n      if colors~='' then\r\n        searchStr=searchStr..'+c='..colors\r\n      end\r\n\r\n      -- is there pow/tou in prefix?\r\n      local power,toughness=nil,nil\r\n      if preToken:find('%d/%d')then\r\n        power,toughness=preToken:match('(%d+)/(%d+)')\r\n        preToken=preToken:gsub('%d+/%d+','')\r\n        searchStr=searchStr..'+pow='..power..'+tou='..toughness\r\n      end\r\n      if preToken:find('x/x')then\r\n        power,toughness='x','x'\r\n        searchStr=searchStr..'+pow='..power..'+tou='..toughness\r\n        preToken=preToken:gsub('x/x','')\r\n      end\r\n\r\n      -- all remaining words in prefix should be type\r\n      local crOn,enOn,arOn=false,false,false\r\n      for type in preToken:gmatch('%S+') do\r\n        success,errorMSG=pcall(function()\r\n          preToken=preToken:gsub(type,'')\r\n        end)\r\n        if success then\r\n          searchStr=searchStr..'+t:'..type\r\n          if type=='creature' then crOn=true end\r\n          if type=='enchantment' then enOn=true end\r\n          if type=='artifact' then arOn=true end\r\n          foundType=true   -- only do the search if some sort of type is detected\r\n        end\r\n      end\r\n      if crOn then      -- it's a creature, specify if it's also an artifact or enchantment\r\n        if not(enOn) then\r\n          searchStr=searchStr..'+-t:enchantment'\r\n        end\r\n        if not(arOn) then\r\n          searchStr=searchStr..'+-t:artifact'\r\n        end\r\n      else\r\n        searchStr=searchStr..'+-t:creature'\r\n      end\r\n\r\n      -- is there a name for the token?\r\n      if postToken:find('named ') then\r\n        local st=postToken:find('named ')+6\r\n        local en=postToken:find('%.',st)\r\n        if en==nil then\r\n          en=postToken:find('%,',st)\r\n        end\r\n        local en2=postToken:find(' with ',st)\r\n        if en2 and en2<en then en=en2 end\r\n        local name=nil\r\n        if st and en then\r\n          name=postToken:sub(st,en-1)\r\n        end\r\n        if name then\r\n          searchStr=searchStr..'+name:\"'..name..'\"'\r\n          if name:find('festering goblin') or name:find('goldmeadow harrier') then\r\n            searchStr=searchStr:gsub('t:token+','')\r\n          end\r\n        end\r\n      end\r\n\r\n      -- is there a quote of text after 'token', e.g. token with \"this creature gets +1/+1\"\r\n      if postToken:find('\"') then\r\n        local q1=postToken:find('\"')\r\n        local q2=postToken:find('\"',q1+1)\r\n        if q1 and q2 then\r\n          local tOracle=postToken:sub(q1,q2)\r\n          -- searchStr=searchStr..'+oracle:'..tOracle   -- can't get this to work\r\n\r\n          -- look for each word in oracle text separately\r\n          tOracle=tOracle:sub(2,-2):gsub('%{.-%}','')..'.'\r\n          for word in tOracle:gmatch('(%a+)%A') do\r\n            searchStr=searchStr..'+oracle:'..word\r\n          end\r\n        end\r\n      end\r\n\r\n      -- look for any keywords in stuff after 'token'\r\n      local keywords={'deathtouch','defender','devour','double strike','flying','haste','infect',\r\n          'hexproof','indestructible','lifelink','menace','reach','trample','vigilance','decayed','training'}\r\n      for _,v in pairs(keywords)do\r\n        if postToken:find(v) then\r\n          searchStr=searchStr..'+keyword:\"'..v..'\"'\r\n          postToken:gsub(v,'')\r\n        else\r\n          searchStr=searchStr..'+-keyword:\"'..v..'\"'\r\n        end\r\n      end\r\n\r\n      -- creature with no other data at all?\r\n      local badStr='t:token+-is:dfc+t:creature+-t:enchantment+-t:artifact+-keyword:\"deathtouch\"+-keyword:\"defender\"+-keyword:\"devour\"+-keyword:\"double strike\"+-keyword:\"flying\"+-keyword:\"haste\"+-keyword:\"infect\"+-keyword:\"hexproof\"+-keyword:\"indestructible\"+-keyword:\"lifelink\"+-keyword:\"menace\"+-keyword:\"reach\"+-keyword:\"trample\"+-keyword:\"vigilance\"+-keyword:\"decayed\"+-keyword:\"training\"'\r\n\r\n      if searchStr:match('zombie') or searchStr:match('treasure') or searchStr:match('clue') then\r\n searchStr=searchStr..'-set:sld'\r\n end\r\n if foundType and searchStr~=badStr then\r\n        -- addNotebookTab({title='token',body='https://api.scryfall.com/cards/search?q='..searchStr})\r\n        nSpawned=nSpawned+1\r\n        table.insert(token_uris,'https://api.scryfall.com/cards/search?q='..searchStr)\r\n      end\r\n    end\r\n  end\r\n\r\n  return token_uris\r\n\r\nend\r\n\r\n-- Parses scryfall response data for a card.\r\n-- Returns a populated card table and a list of tokens.\r\nlocal function parseCardData(cardID, data)\r\n    local tokens = {}\r\n    local oracle=''\r\n    if data.card_faces then\r\n      oracle=oracle..'\\n'..data.card_faces[1].oracle_text\r\n      oracle=oracle..'\\n'..data.card_faces[2].oracle_text\r\n    else\r\n      oracle=data.oracle_text\r\n    end\r\n    oracle=oracle:lower()\r\n    if data.all_parts and not (data.layout == \"token\") then\r\n        for _, part in ipairs(data.all_parts) do\r\n            if part.type_line:lower():find('emblem') or (part.component and part.component == \"token\") then\r\n                table.insert(tokens, {\r\n                    name = part.name,\r\n                    scryfallID = part.id,\r\n                    uri = part.uri\r\n                })\r\n            end\r\n        end\r\n    elseif not(data.all_parts) and ((oracle:find('create') and oracle:find(' token')) or oracle:find(' emblem')) then\r\n      local tokenURLs=parseForToken(oracle)\r\n      for _,url in ipairs(tokenURLs) do\r\n        -- addNotebookTab({title='url',body=url})\r\n        table.insert(tokens, {\r\n            uri = url\r\n        })\r\n      end\r\n    end\r\n\r\n    -- pieHere: non-en languages have their own fields for these\r\n    if data.lang~='en' then\r\n      data.name = data.printed_name or data.name\r\n      data.type_line = data.printed_type_line or data.type_line\r\n      data.oracle_text = data.printed_text or data.oracle_text\r\n      if data.card_faces then\r\n        for i, face in ipairs(data.card_faces) do\r\n          data.card_faces[i].name=data.card_faces[i].printed_name or data.card_faces[i].name\r\n          data.card_faces[i].type_line=data.card_faces[i].printed_type_line or data.card_faces[i].type_line\r\n          data.card_faces[i].oracle_text=data.card_faces[i].printed_text or data.card_faces[i].oracle_text\r\n        end\r\n      end\r\n    end\r\n\r\n    local imagesuffix=''\r\n    if cacheBuster or data.image_status~='highres_scan' then\r\n      imagesuffix='?'..tostring(os.date(\"%x\")):gsub('/', '')\r\n    end\r\n\r\n    local card = shallowCopyTable(cardID)\r\n    card.name = getAugmentedName(data)\r\n    card.oracleText = collectOracleText(data)\r\n    card.faces = {}\r\n    card.scryfallID = data.id\r\n    card.oracleID = data.oracle_id\r\n    card.language = data.lang\r\n    card.setCode = data.set\r\n    card.collectorNum = data.collector_number\r\n    card.all_parts_json = all_parts_json\r\n    if data.layout == \"reversible_card\" or data.layout == \"transform\" or data.layout == \"art_series\" or data.layout == \"double_sided\" or data.layout == \"modal_dfc\" then\r\n        for i, face in ipairs(data.card_faces) do\r\n            card['faces'][i] = {\r\n                imageURI = stripScryfallImageURI(face.image_uris[getQuality()])..imagesuffix,\r\n                name = getAugmentedName(data,i),\r\n                oracleText = collectOracleText(data,i),\r\n            }\r\n        end\r\n        card['doubleface'] = true\r\n        if combineStates then\r\n          DFCloaded=true\r\n          card['doubleface'] = false\r\n        end\r\n    elseif data.layout == \"double_faced_token\" then\r\n        for i, face in ipairs(data.card_faces) do\r\n            card['faces'][i] = {\r\n                imageURI = stripScryfallImageURI(face.image_uris[getQuality()])..imagesuffix,\r\n                name = getAugmentedName(data,i),\r\n                oracleText = collectOracleText(data,i),\r\n            }\r\n        end\r\n        card['doubleface'] = false -- Not putting double-face tokens in double-face cards pile\r\n    else\r\n        card['faces'][1] = {\r\n            imageURI = stripScryfallImageURI(data.image_uris[getQuality()])..imagesuffix,\r\n            name = card.name,\r\n            oracleText = card.oracleText,\r\n        }\r\n        card['doubleface'] = false\r\n    end\r\n\r\n    return card, tokens\r\nend\r\n\r\n-- Queries scryfall by the [cardID].\r\n-- cardID must define at least one of scryfallID, multiverseID, or name.\r\n-- if forceNameQuery is true, will query scryfall by card name ignoring other data.\r\n-- onSuccess is called with a populated card table, and a table of associated token cardIDs.\r\nlocal function queryCard(cardID, forceNameQuery, forceSetNumLangQuery, onSuccess, onError)\r\n\r\n    local query_url\r\n    local language_code = getLanguageCode()\r\n\r\n    if cardID.name then\r\n      cardID.name= cardID.name:gsub('%A','')\r\n    end\r\n\r\n    if cardID.name and string.find('plains island mountain swamp forest',cardID.name:lower()) and not(cardID.setCode) then\r\n      cardID.setCode='znr'\r\n    end\r\n\r\n    if cardID.uri then\r\n        query_url = cardID.uri\r\n    elseif forceNameQuery then\r\n        query_url = SCRYFALL_NAME_BASE_URL .. cardID.name\r\n    elseif cardID.scryfallID and string.len(cardID.scryfallID) > 0 then\r\n        query_url = SCRYFALL_ID_BASE_URL .. cardID.scryfallID\r\n    elseif cardID.multiverseID and string.len(cardID.multiverseID) > 0 then\r\n        query_url = SCRYFALL_MULTIVERSE_BASE_URL .. cardID.multiverseID\r\n    elseif cardID.setCode and string.len(cardID.setCode) > 0 and cardID.collectorNum and string.len(cardID.collectorNum) > 0 then\r\n        query_url = SCRYFALL_SET_NUM_BASE_URL .. string.lower(cardID.setCode) .. \"/\" .. cardID.collectorNum .. \"/\" .. language_code\r\n    elseif cardID.setCode and string.len(cardID.setCode) > 0 then\r\n        query_string = \"order:released s:\" .. string.lower(cardID.setCode) .. \" !\" .. cardID.name\r\n        query_url = SCRYFALL_SEARCH_BASE_URL .. query_string\r\n    else\r\n        query_url = SCRYFALL_NAME_BASE_URL .. cardID.name\r\n    end\r\n\t\r\n    webRequest = WebRequest.get(query_url, function(webReturn)\r\n\r\n        if webReturn.is_error or webReturn.error then\r\n            onError(query_url..\"\\nWeb request error: \" .. webReturn.error or \"unknown\")\r\n            return\r\n        elseif string.len(webReturn.text) == 0 then\r\n            onError(query_url..\"\\nempty response\")\r\n            return\r\n        end\r\n\r\n        local success,data\r\n        if webReturn.text:sub(1,16)=='{\"object\":\"list\"' then\r\n          success,data = pcall(function() return getNextCardDatFromList(webReturn.text,1) end)\r\n          if not success then\r\n            onError(query_url..\"\\nsomething went wrong with Pie's the getNextCardDatFromList\")\r\n            return\r\n          end\r\n        elseif webReturn.text:sub(1,16)=='{\"object\":\"card\"' then\r\n          success, data = pcall(function() return JSONdecode(webReturn.text) end)\r\n          -- log(query_url,success)\r\n          if not success then\r\n              onError(query_url..\"\\nfailed to parse JSON response\")\r\n              return\r\n          elseif not data then\r\n              onError(query_url..\"\\nempty JSON response\")\r\n              return\r\n          elseif data.object == \"error\" then\r\n              onError(query_url..\"\\nfailed to find card\")\r\n              return\r\n          end\r\n        else\r\n          onError(query_url..\"\\nPie's parser somehow got a webReturn that is not a card or a list\")\r\n          return\r\n        end\r\n\r\n        -- language-support rework\r\n        if data.lang==language_code or (language_code=='en' and cardID.scryfallID and string.len(cardID.scryfallID)>0) then\r\n          local card, tokens = parseCardData(cardID, data)\r\n          onSuccess(card, tokens)\r\n        else\r\n\r\n          -- try 1: look for the language-specific card from the same set\r\n          local lang_url1=SCRYFALL_SET_NUM_BASE_URL .. data.set .. \"/\" .. data.collector_number .. \"/\" .. language_code\r\n          WebRequest.get(lang_url1, function(webReturn)\r\n            success,lang_data = pcall(function() return JSONdecode(webReturn.text) end)\r\n            -- log(lang_url1,success)\r\n            if success and lang_data~=nil and lang_data.object~='error' and lang_data.image_status~='placeholder' then\r\n              data=lang_data\r\n              local card, tokens = parseCardData(cardID, data)\r\n              onSuccess(card, tokens)\r\n            else\r\n              -- try 2: look for the language specific card from any set\r\n              local lang_url2=SCRYFALL_SEARCH_BASE_URL..'!'..data.name:gsub('%A','') .. '+lang%3A' .. language_code\r\n              WebRequest.get(lang_url2, function(webReturn)\r\n                success,lang_data = pcall(function() return getNextCardDatFromList(webReturn.text,1) end)\r\n                -- log(lang_url2,success)\r\n                if success and lang_data~=nil and lang_data.object~='error' and lang_data.image_status~='placeholder' then\r\n                  -- if lang_data.image_status=='placeholder' then    -- if no image, but the rest of the data is present?\r\n                  --   if data.card_faces then\r\n                  --     lang_data.card_faces[1].image_uris.large=data.card_faces[1].image_uris.large\r\n                  --     lang_data.card_faces[2].image_uris.large=data.card_faces[2].image_uris.large\r\n                  --   elseif data.image_uris then\r\n                  --     lang_data.image_uris.large=data.image_uris.large\r\n                  --   end\r\n                  -- end\r\n                  data=lang_data\r\n                else\r\n                  printToColor(\"Could not find \"..language_code:upper()..\" version for: \"..data.name,playerColor,{1,1,0})\r\n                end\r\n                local card, tokens = parseCardData(cardID, data)  -- use original data if lang-specific card was not found\r\n                onSuccess(card, tokens)\r\n              end)\r\n            end\r\n          end)\r\n        end\r\n\r\n    end)\r\nend\r\n\r\n-- Queries card data for all cards.\r\n-- TO-DO use the bulk api\r\n-- PieHere: bulk API is crazy, the minimum would be parsing an ~80MB file, no way TTS's JSON.decode would handle that\r\n-- at this size I feel parsing the text manually would also be kinda nuts... but possible ;-)\r\nlocal function fetchCardData(cards, onComplete, onError)\r\n    local sem = 0\r\n    local function incSem() sem = sem + 1 end\r\n    local function decSem() sem = sem - 1 end\r\n\r\n    local cardData = {}\r\n    local tokenIDs = {}\r\n\r\n    local function onQuerySuccess(card, tokens)\r\n\r\n        local rmfields={'multiverse_ids','colors','color_identity','keywords',\r\n                  'all_parts','legalities','games','artist_ids','promo_types',\r\n                  'prices','related_uris','purchase_uris'}\r\n        local ntp=0\r\n        local ntd=0\r\n        local all_parts_json=''\r\n        if cardTokenDat then\r\n          for iii,t in ipairs(tokens) do\r\n            ntp=ntp+1\r\n            WebRequest.get(t.uri,function(wrt)\r\n              local txt=wrt.text\r\n              local cardStart=string.find(txt,'{\"object\":\"card\"',0)\r\n              local cardEnd = findClosingBracket(txt,cardStart)\r\n              if cardStart~=nil and cardEnd~=nil then\r\n                txt=txt:sub(cardStart,cardEnd)\r\n                for _,rmfield in ipairs(rmfields) do\r\n                  local st=txt:find('\"'..rmfield..'\"'..':')\r\n                  if st~=nil then\r\n                    local en=findClosingBracket(txt,st+string.len('\"'..rmfield..'\"'..':'))\r\n                    txt=txt:sub(1,st-1)..txt:sub(en+2,-1)\r\n                  end\r\n                end\r\n                txt=txt:sub(1,-2)..'}'\r\n                local comma=''\r\n                if ntd>0 then\r\n                  comma=','\r\n                end\r\n                all_parts_json=all_parts_json..comma..txt\r\n                ntd=ntd+1\r\n              else\r\n                ntp=ntp-1\r\n              end\r\n              if ntd==ntp and ntp>0 then\r\n                all_parts_json='{\"object\":\"list\",\"total_cards\":'..ntd..',\"data\":['..all_parts_json..']}'\r\n              end\r\n            end)\r\n            if iii>5 then break end\r\n          end\r\n        end\r\n\r\n        Wait.condition(function()\r\n          card.all_parts_json=all_parts_json\r\n          table.insert(cardData, card)\r\n          for _, token in ipairs(tokens) do\r\n              table.insert(tokenIDs, token)\r\n          end\r\n          decSem()\r\n        end,function() return ntp==ntd end)\r\n\r\n    end\r\n\r\n    local function onQueryFailed(e)\r\n        -- printErr(\"Error querying scryfall: \" .. e)\r\n        decSem()\r\n    end\r\n\r\n    for _, cardID in ipairs(cards) do\r\n        incSem()\r\n        queryCard(\r\n            cardID,\r\n            false,\r\n            false,\r\n            onQuerySuccess,\r\n            function(e) -- onError\r\n                -- try again, forcing query-by-name.\r\n                queryCard(\r\n                    cardID,\r\n                    true,\r\n                    false,\r\n                    onQuerySuccess,\r\n                    onQueryFailed\r\n                )\r\n            end\r\n        )\r\n    end\r\n\r\n    Wait.condition(\r\n        function() onComplete(cardData, tokenIDs) end,\r\n        function() return (sem == 0) end,\r\n        30,\r\n        function() onError(\"Error loading card images... timed out.\") end\r\n    )\r\nend\r\n\r\n-- Queries for the given card IDs, collates deck, and spawns objects.\r\nlocal function loadDeck(cardIDs, deckName, onComplete, onError)\r\n    local maindeckPosition = self.positionToWorld(MAINDECK_POSITION_OFFSET)\r\n    local doublefacePosition = self.positionToWorld(DOUBLEFACE_POSITION_OFFSET)\r\n    local sideboardPosition = self.positionToWorld(SIDEBOARD_POSITION_OFFSET)\r\n    local commanderPosition = self.positionToWorld(COMMANDER_POSITION_OFFSET)\r\n    local tokensPosition = self.positionToWorld(TOKENS_POSITION_OFFSET)\r\n\r\n    printInfo(\"Querying Scryfall for card data...\")\r\n\r\n    fetchCardData(cardIDs, function(cards, tokenIDs)\r\n        if tokenIDs and tokenIDs[1] then\r\n            printInfo(\"Querying Scryfall for tokens...\")\r\n        end\r\n\r\n        fetchCardData(tokenIDs, function(tokens, _)\r\n            local maindeck = {}\r\n            local sideboard = {}\r\n            local commander = {}\r\n            local doubleface = {}\r\n\r\n            for _, card in ipairs(cards) do\r\n                if card.sideboard then\r\n                    table.insert(sideboard, card)\r\n                elseif card.commander then\r\n                    table.insert(commander, card)\r\n                elseif card.doubleface then\r\n                    table.insert(doubleface, card)\r\n                else\r\n                    table.insert(maindeck, card)\r\n                end\r\n            end\r\n\r\n            printInfo(\"Spawning deck...\")\r\n\r\n            local sem = 5\r\n            local function decSem() sem = sem - 1 end\r\n\r\n            local flipped=false\r\n\t\t\t\r\n            spawnDeck(maindeck, deckName .. \"\\n[i]Maindeck[/i]\", maindeckPosition, flipped,\r\n                function() -- onSuccess\r\n                    decSem()\r\n                end,\r\n                function(e) -- onError\r\n                    printErr(e)\r\n                    decSem()\r\n                end\r\n            )\r\n\r\n            spawnDeck(doubleface, deckName .. \"\\n[i]Double Face Cards[/i]\", doublefacePosition, flipped,\r\n                function() -- onSuccess\r\n                    decSem()\r\n                end,\r\n                function(e) -- onError\r\n                    printErr(e)\r\n                    decSem()\r\n                end\r\n            )\r\n\r\n            spawnDeck(sideboard, deckName .. \"\\n[i]Sideboard[/i]\", sideboardPosition, flipped,\r\n                function() -- onSuccess\r\n                    decSem()\r\n                end,\r\n                function(e) -- onError\r\n                    printErr(e)\r\n                    decSem()\r\n                end\r\n            )\r\n\r\n            spawnDeck(commander, deckName .. \"\\n[i]Commanders[/i]\", commanderPosition, flipped,\r\n                function() -- onSuccess\r\n                    decSem()\r\n                end,\r\n                function(e) -- onError\r\n                    printErr(e)\r\n                    decSem()\r\n                end\r\n            )\r\n\r\n            spawnDeck(tokens, deckName .. \"\\n[i]Tokens[/i]\", tokensPosition, flipped,\r\n                function() -- onSuccess\r\n                    decSem()\r\n                end,\r\n                function(e) -- onError\r\n                    printErr(e)\r\n                    decSem()\r\n                end\r\n            )\r\n\r\n            Wait.condition(\r\n                function() onComplete() end,\r\n                function() return (sem == 0) end,\r\n                30,\r\n                function() onError(\"Error spawning deck objects... timed out.\") end\r\n            )\r\n        end, onError)\r\n    end, onError)\r\nend\r\n\r\n------ DECK BUILDER SCRAPING\r\nlocal function parseMTGALine(line)\r\n    -- Parse out card count if present\r\n    local count, countIndex = string.match(line, \"^%s*(%d+)[x%*]?%s+()\")\r\n    if count and countIndex then\r\n        line = string.sub(line, countIndex)\r\n    else\r\n        count = 1\r\n    end\r\n\r\n    local name, setCode, collectorNum = string.match(line, \"([^%(%)]+) %(([%d%l%u]+)%) ([%d%l%u]+)\")\r\n\r\n    if not name then\r\n        name, setCode = string.match(line, \"([^%(%)]+) %(([%d%l%u]+)%)\")\r\n    end\r\n\r\n    if not name then\r\n       name = string.match(line, \"([^%(%)]+)\")\r\n    end\r\n\r\n    -- MTGA format uses DAR for dominaria for some reason, which scryfall can't find.\r\n    if setCode == \"DAR\" then\r\n        setCode = \"DOM\"\r\n    end\r\n\r\n    return name, count, setCode, collectorNum\r\nend\r\n\r\nlocal function queryDeckNotebook(_, onSuccess, onError)\r\n    local bookContents = readNotebookForColor(playerColor)\r\n\r\n    if bookContents == nil then\r\n        onError(\"Notebook not found: \" .. playerColor)\r\n        return\r\n    elseif string.len(bookContents) == 0 then\r\n        onError(\"Notebook is empty. Please paste your decklist into your notebook (\" .. playerColor .. \").\")\r\n        return\r\n    end\r\n\r\n    local cards = {}\r\n\r\n    local i = 1\r\n    local mode = \"deck\"\r\n    for line in iterateLines(bookContents) do\r\n        if string.len(line) > 0 then\r\n            if line:gsub('%A',''):lower() == \"commander\" then\r\n                mode = \"commander\"\r\n            elseif line:gsub('%A',''):lower() == \"sideboard\" then\r\n                mode = \"sideboard\"\r\n            elseif line:gsub('%A',''):lower() == \"deck\" then\r\n                mode = \"deck\"\r\n            else\r\n                local name, count, setCode, collectorNum = parseMTGALine(line)\r\n\r\n                if name then\r\n                    cards[i] = {\r\n                        count = count,\r\n                        name = name,\r\n                        setCode = setCode,\r\n                        collectorNum = collectorNum,\r\n                        sideboard = (mode == \"sideboard\"),\r\n                        commander = (mode == \"commander\")\r\n                    }\r\n\r\n                    i = i + 1\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    onSuccess(cards, \"Notebook Deck\")\r\nend\r\n\r\nlocal function parseDeckIDTappedout(s)\r\n    -- NOTE: need to do this in multiple parts because TTS uses an old version\r\n    -- of lua with hilariously sad pattern matching\r\n\r\n    local urlSuffix = s:match(\"tappedout%.net/mtg%-decks/(.*)\")\r\n    if urlSuffix then\r\n        return urlSuffix:match(\"([^%s%?/$]*)\")\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nlocal function queryDeckTappedout(slug, onSuccess, onError)\r\n    if not slug or string.len(slug) == 0 then\r\n        onError(\"Invalid tappedout deck slug: \" .. slug)\r\n        return\r\n    end\r\n\r\n    local url = TAPPEDOUT_BASE_URL .. slug .. TAPPEDOUT_URL_SUFFIX\r\n    printInfo(\"Fetching decklist from tappedout...\")\r\n\r\n    local deckName=nil      -- get original deck name\r\n    WebRequest.get('https://tappedout.net/mtg-decks/'..slug..'/',function(webReturn)\r\n        local st=webReturn.text:find('<title>')+7\r\n        local en=webReturn.text:find('</title>')-1\r\n        deckName=webReturn.text:sub(st,en):gsub('&#x(%x%x);',function (x) return string.char(tonumber(x,16)) end):gsub('( %(.-%))','')\r\n    end)\r\n\r\n    Wait.condition(function()\r\n        WebRequest.get(url .. \"?fmt=csv\", function(webReturn)\r\n            if webReturn.error then\r\n                if string.match(webReturn.error, \"(404)\") then\r\n                    onError(\"Deck not found. Is it public?\")\r\n                else\r\n                    onError(\"Web request error: \" .. webReturn.error)\r\n                end\r\n                return\r\n            elseif webReturn.is_error then\r\n                onError(\"Web request error: unknown\")\r\n                return\r\n            elseif string.len(webReturn.text) == 0 then\r\n                onError(\"Web request error: empty response\")\r\n                return\r\n            end\r\n\r\n            cvsData = webReturn.text\r\n\r\n            local cards = {}\r\n\r\n            local i = 1\r\n            local lineN=1\r\n            for line in iterateLines(cvsData) do\r\n              if string.len(line) > 0 then\r\n                -- Amuzet's \"remove commas in card name regex\" (I can't fully follow it.. but I can copy it)\r\n                line=', '..line:gsub(',(\"[^\"]+\"),',function(g)return','..g:gsub(',',''):gsub('\"','')..','end):gsub(',',', ')\r\n                if lineN>1 then\r\n                  -- Board,Qty,Name,Printing,Foil,Alter,Signed,Condition,Language,Commander\r\n                  rowdat={}\r\n                  for dat in line:gmatch(',([^,]+)') do\r\n                    table.insert(rowdat,dat:sub(2))\r\n                  end\r\n                  if rowdat[1]~='maybe' and rowdat[1]~='acquire' then\r\n                    cards[i] = {\r\n                        count = tonumber(rowdat[2]),\r\n                        name = rowdat[3],\r\n                        setCode = rowdat[4],\r\n                        sideboard = (rowdat[1] == 'side'),\r\n                        commander = (rowdat[10] == 'True')\r\n                    }\r\n                    i=i+1\r\n                  end\r\n                end\r\n              end\r\n              lineN=lineN+1\r\n            end\r\n            onSuccess(cards, deckName)\r\n        end)\r\n    end, function() return deckName~=nil end)\r\nend\r\n\r\nlocal function parseDeckIDArchidekt(s)\r\n    return s:match(\"archidekt%.com/decks/(%d*)\")\r\nend\r\n\r\nlocal function queryDeckArchidekt(deckID, onSuccess, onError)\r\n    if not deckID or string.len(deckID) == 0 then\r\n        onError(\"Invalid archidekt deck: \" .. deckID)\r\n        return\r\n    end\r\n\r\n    local url = ARCHIDEKT_BASE_URL .. deckID .. ARCHIDEKT_URL_SUFFIX\r\n\t\r\n    printInfo(\"Fetching decklist from archidekt...\")\r\n\r\n    WebRequest.get(url, function(webReturn)\r\n        if webReturn.error then\r\n            if string.match(webReturn.error, \"(404)\") then\r\n                onError(\"Deck not found. Is it public?\")\r\n            else\r\n                onError(\"Web request error: \" .. webReturn.error)\r\n            end\r\n            return\r\n        elseif webReturn.is_error then\r\n            onError(\"Web request error: unknown\")\r\n            return\r\n        elseif string.len(webReturn.text) == 0 then\r\n            onError(\"Web request error: empty response\")\r\n            return\r\n        end\r\n\t\t\r\n        -- pieHere: manual archidekt parsing\r\n        local success, data = pcall(function()\r\n\r\n          local startInd=1\r\n          local endInd\r\n          local keepGoing=true\r\n          local cards={}\r\n          local categories={}\r\n          local catSt=webReturn.text:find('\"categories\":%[{\"id\"')\r\n          catSt=catSt+13\r\n          local catEn=findClosingBracket(webReturn.text,catSt)\r\n          local categoriesSnip=webReturn.text:sub(catSt,catEn)\r\n          local st,en=0,0\r\n          n=0\r\n          while keepGoing do\r\n            st=categoriesSnip:find('{',en)\r\n            if st==nil then keepGoing=false break end\r\n            en=categoriesSnip:find('}',st)\r\n            if en==nil then keepGoing=false break end\r\n            local name=categoriesSnip:sub(st,en):match('\"name\":\"(.-)\"')\r\n            local include=categoriesSnip:sub(st,en):match('\"includedInDeck\":(.-),')\r\n\t\t\tif name~=nil then\r\n\t\t\t\tcategories[name]=include~='false'\r\n\t\t\tend\r\n          end\r\n\r\n          local keepGoing=true\r\n          n=0\r\n          while keepGoing do\r\n            n=n+1\r\n            if n==1 then\r\n              startInd=webReturn.text:find('\"cards\":%[{\"id\":',startInd)\r\n            else\r\n              startInd=webReturn.text:find(',{\"id\":',startInd)\r\n            end\r\n            if startInd==nil then keepGoing=false break end\r\n            if n==1 then\r\n              startInd=startInd+9\r\n            else\r\n              startInd=startInd+1\r\n            end\r\n            endInd=findClosingBracket(webReturn.text,startInd)\r\n            if endInd==nil then keepGoing=false break end\r\n\r\n            local cardSnip = webReturn.text:sub(startInd,endInd)\r\n            if not(cardSnip:match('\"card\":')) then\r\n              keepGoing=false break\r\n            end\r\n\r\n            card={\r\n              quantity=cardSnip:match('\"quantity\":(%d+)'),\r\n              name=cardSnip:match('\"name\":\"(.-)\"'):gsub(\"\\\\u(%x%x%x%x)\",function (x) return string.char(tonumber(x,16)) end),\r\n              scryfall_id=cardSnip:match('\"uid\":\"(.-)\"'),\r\n              category=cardSnip:match('\"categories\":%[\"(.-)\"')\r\n            }\r\n            table.insert(cards,card)\r\n            startInd=endInd+1\r\n          end\r\n\t\t  local deckName=webReturn.text:sub(1,100):match('\"name\":\"(.-)\"')\r\n          data={cards=cards,categories=categories,deckName=deckName}\r\n          return data\r\n        end)\r\n        ------------------------------------------------------------------------\r\n\r\n        if not success then\r\n            onError(\"Failed to parse JSON response from archidekt.\")\r\n            print(data)\r\n            return\r\n        elseif not data then\r\n            onError(\"Empty response from archidekt.\")\r\n            return\r\n        elseif not data.cards then\r\n            onError(\"Empty response from archidekt. Did you enter a valid deck URL?\")\r\n            return\r\n        end\r\n\r\n        local deckName = data.deckName\r\n        local cards = {}\r\n\r\n        for i, card in ipairs(data.cards) do\r\n            if card.category~=\"Maybeboard\" then\r\n                cards[#cards+1] = {\r\n                    count = card.quantity,\r\n                    sideboard = card.category==\"Sideboard\" or (card.category~=nil and not(data.categories[card.category])),\r\n                    commander = card.category==\"Commander\",\r\n                    name = card.name,\r\n                    scryfallID = card.scryfall_id,\r\n                }\r\n            end\r\n        end\r\n\r\n        onSuccess(cards, deckName)\r\n    end)\r\nend\r\n\r\nlocal function parseDeckIDMoxfield(s)\r\n    local urlSuffix = s:match(\"moxfield%.com/decks/(.*)\")\r\n    if urlSuffix then\r\n        return urlSuffix:match(\"([^%s%?/$]*)\")\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nlocal function queryDeckMoxfield(deckID, onSuccess, onError)\r\n    if not deckID or string.len(deckID) == 0 then\r\n        onError(\"Invalid moxfield deck: \" .. deckID)\r\n        return\r\n    end\r\n\r\n    local url = MOXFIELD_BASE_URL .. deckID .. MOXFIELD_URL_SUFFIX\r\n    printInfo(\"Fetching decklist from moxfield...\")\r\n\r\n\tWebRequest.custom(url, \"get\", true, nil, headers, function(webReturn)\r\n        if webReturn.error then\r\n            if string.match(webReturn.error, \"(404)\") then\r\n                onError(\"Deck not found. Is it public?\")\r\n            else\r\n                onError(\"Web request error: \" .. webReturn.error)\r\n            end\r\n            return\r\n        elseif webReturn.is_error then\r\n            onError(\"Web request error: unknown\")\r\n            return\r\n        elseif string.len(webReturn.text) == 0 then\r\n            onError(\"Web request error: empty response\")\r\n            return\r\n        end\r\n\r\n        ------------------------------------------------------------------------\r\n        -- pieHere, manual moxfield parser\r\n        -- could/should move it to a separate function and use pcall?\r\n        local deckName = getKeyValue(webReturn.text,'name',1)\r\n        local commanderIDs = {}\r\n        local cards = {}\r\n        local data={}\r\n        local sections={'mainboard','commanders','companions','signatureSpells','sideboard'}\r\n        for _,section in ipairs(sections) do\r\n          -- section text extraction\r\n          local sectionSearch='\"'..section..'\":{'\r\n          local bracketShift=string.len(sectionSearch)\r\n          local sectionStart=string.find(webReturn.text,sectionSearch)+bracketShift-1\r\n          local sectionEnd=findClosingBracket(webReturn.text,sectionStart)\r\n          local sectionTxt = webReturn.text:sub(sectionStart,sectionEnd)\r\n\r\n          -- extracting cardDats from each section\r\n          local sectionDat={}\r\n          local st=1\r\n          local en=1\r\n          local keepGoing=true\r\n          while keepGoing do\r\n            st=string.find(sectionTxt,'{\"quantity\":',st)    -- it appears every card section starts with quantity?\r\n            if st==nil then keepGoing=false break end\r\n\r\n            en=findClosingBracket(sectionTxt,st)\r\n            if en==nil then keepGoing=false break end\r\n\r\n            local cardTxt=sectionTxt:sub(st,en)\r\n            local dat={quantity=nil,card={id=nil,name=nil}}\r\n            dat.quantity  = getKeyValue(cardTxt,'quantity',1)\r\n            dat.card.id   = getKeyValue(cardTxt,'scryfall_id',1)\r\n            dat.card.name = getKeyValue(cardTxt,'name',1)\r\n\r\n            table.insert(sectionDat,dat)    -- populate sectionDat\r\n            st=en+1\r\n          end\r\n          data[section]=sectionDat\r\n        end\r\n        ------------------------------------------------------------------------\r\n\r\n        for name, cardData in pairs(data.commanders or {}) do\r\n            if cardData.card then\r\n                commanderIDs[cardData.card.id] = true\r\n                table.insert(cards, {\r\n                    name = cardData.card.name,\r\n                    count = cardData.quantity,\r\n                    scryfallID = cardData.card.id,\r\n                    sideboard = false,\r\n                    commander = true,\r\n                })\r\n            end\r\n        end\r\n\r\n        for name, cardData in pairs(data.companions or {}) do\r\n            if cardData.card then\r\n                commanderIDs[cardData.card.id] = true\r\n                table.insert(cards, {\r\n                    name = cardData.card.name,\r\n                    count = cardData.quantity,\r\n                    scryfallID = cardData.card.id,\r\n                    sideboard = false,\r\n                    commander = true,\r\n                })\r\n            end\r\n        end\r\n\r\n        for name, cardData in pairs(data.signatureSpells or {}) do\r\n            if cardData.card then\r\n                commanderIDs[cardData.card.id] = true\r\n                table.insert(cards, {\r\n                    name = cardData.card.name,\r\n                    count = cardData.quantity,\r\n                    scryfallID = cardData.card.id,\r\n                    sideboard = false,\r\n                    commander = true,\r\n                })\r\n            end\r\n        end\r\n\r\n        for name, cardData in pairs(data.mainboard) do\r\n            if cardData.card and not commanderIDs[cardData.card.id] then\r\n                table.insert(cards, {\r\n                    name = cardData.card.name,\r\n                    count = cardData.quantity,\r\n                    scryfallID = cardData.card.id,\r\n                    sideboard = false,\r\n                    commander = false,\r\n                })\r\n            end\r\n        end\r\n\r\n        for name, cardData in pairs(data.sideboard or {}) do\r\n            if cardData.card and not commanderIDs[cardData.card.id] then\r\n                table.insert(cards, {\r\n                    name = cardData.card.name,\r\n                    count = cardData.quantity,\r\n                    scryfallID = cardData.card.id,\r\n                    sideboard = true,\r\n                    commander = false,\r\n                })\r\n            end\r\n        end\r\n\r\n        onSuccess(cards, deckName)\r\n    end)\r\nend\r\n\r\nlocal function parseDeckIDDeckstats(s)\r\n    local deckURL = s:match(\"(deckstats%.net/decks/%d*/[^/]*)\")\r\n    return deckURL\r\nend\r\n\r\nlocal function queryDeckDeckstats(deckURL, onSuccess, onError)\r\n    if not deckURL or string.len(deckURL) == 0 then\r\n        onError(\"Invalid deckstats URL: \" .. deckURL)\r\n        return\r\n    end\r\n\r\n    local url = deckURL .. DECKSTATS_URL_SUFFIX\r\n    local url0= deckURL .. '?include_comments=1&export_dec=1'\r\n\r\n    printInfo(\"Fetching decklist from deckstats...\")\r\n\r\n    -- grab commander from '?include_comments=1&export_dec=1'\r\n    local commanderParsed=false\r\n    local commanders={}\r\n    local deckName = deckURL:match(\"deckstats%.net/decks/%d*/%d*-([^/?]*)\"):gsub('-',' ')\r\n    WebRequest.get(url0, function(webReturn)\r\n        if webReturn.error then\r\n            if string.match(webReturn.error, \"(404)\") then\r\n                onError(\"Deck not found. Is it public?\")\r\n            else\r\n                onError(\"Web request error: \" .. webReturn.error)\r\n            end\r\n            return\r\n        elseif webReturn.is_error then\r\n            onError(\"Web request error: unknown\")\r\n            return\r\n        elseif string.len(webReturn.text) == 0 then\r\n            onError(\"Web request error: empty response\")\r\n            return\r\n        end\r\n\r\n        for line in iterateLines(webReturn.text) do\r\n            if line:match('//NAME:') then\r\n                deckName=line:match('//NAME: (.-) from deckstats.net')\r\n            end\r\n            if line:match('# !Commander') then\r\n                local cmdname=line:gsub('%d',''):gsub('//.+',''):gsub('#.*',''):gsub('%W',''):lower()\r\n                table.insert(commanders,cmdname)\r\n            end\r\n        end\r\n        commanderParsed=true\r\n    end)\r\n\r\n    -- use '?include_comments=1&export_mtgarena=1' to get the listed printing of each card\r\n    Wait.condition(function()\r\n        WebRequest.get(url, function(webReturn)\r\n            if webReturn.error then\r\n                if string.match(webReturn.error, \"(404)\") then\r\n                    onError(\"Deck not found. Is it public?\")\r\n                else\r\n                    onError(\"Web request error: \" .. webReturn.error)\r\n                end\r\n                return\r\n            elseif webReturn.is_error then\r\n                onError(\"Web request error: unknown\")\r\n                return\r\n            elseif string.len(webReturn.text) == 0 then\r\n                onError(\"Web request error: empty response\")\r\n                return\r\n            end\r\n\r\n            local cards = {}\r\n\r\n            local i = 1\r\n            local mode = \"deck\"\r\n            for line in iterateLines(webReturn.text) do\r\n                if string.len(line) == 0 then\r\n                    mode = \"sideboard\"\r\n                else\r\n                    local commentPos = line:find(\"#\")\r\n                    if commentPos then\r\n                        line = line:sub(1, commentPos)\r\n                    end\r\n\r\n                    local name, count, setCode, collectorNum = parseMTGALine(line)\r\n\r\n                    for _,cmdname in pairs(commanders) do\r\n                        if name:gsub('%d',''):gsub('//.+',''):gsub('#.*',''):gsub('%W',''):lower()==cmdname then\r\n                            isCommander=true\r\n                        else\r\n                            isCommander=false\r\n                        end\r\n                    end\r\n\r\n                    if name then\r\n                        cards[i] = {\r\n                          count = count,\r\n                          name = name,\r\n                          setCode = setCode,\r\n                          collectorNum = collectorNum,\r\n                          sideboard = (mode == \"sideboard\"),\r\n                          commander = isCommander\r\n                        }\r\n\r\n                        i = i + 1\r\n                    end\r\n                end\r\n            end\r\n\r\n            onSuccess(cards, deckName)\r\n        end)\r\n    end, function() return commanderParsed end)\r\nend\r\n\r\n\r\nlocal function queryDeckGoldfish(deckID, onSuccess, onError)\r\n\r\n    if not deckID or string.len(deckID) == 0 then\r\n        onError(\"Invalid mtggoldfish deck: \" .. deckID)\r\n        return\r\n    end\r\n\r\n    local url = 'https://www.mtggoldfish.com/deck/arena_download/' .. deckID .. '/'\r\n    local url0= 'https://www.mtggoldfish.com/deck/download/' .. deckID .. '/'\r\n\r\n    printInfo(\"Fetching decklist from mtggoldfish...\")\r\n\r\n    deckName=nil\r\n\r\n    WebRequest.get(url0, function(webReturn)      -- this here is just to get the deck name\r\n      local contentDisposition = webReturn.getResponseHeader(\"Content-Disposition\")\r\n      local _, _, filename = string.find(contentDisposition, \"filename=\\\"(.+)\\\"\")\r\n      deckName = filename:gsub('Deck - ',''):gsub('.txt','')\r\n    end)\r\n\r\n    Wait.condition(function()   -- wait until deckName is parsed from other url\r\n      WebRequest.get(url, function(webReturn)\r\n          if webReturn.error then\r\n              if string.match(webReturn.error, \"(404)\") then\r\n                  onError(\"Deck not found. Is it public?\")\r\n              else\r\n                  onError(\"Web request error: \" .. webReturn.error)\r\n              end\r\n              return\r\n          elseif webReturn.is_error then\r\n              onError(\"Web request error: unknown\")\r\n              return\r\n          elseif string.len(webReturn.text) == 0 then\r\n              onError(\"Web request error: empty response\")\r\n              return\r\n          end\r\n\r\n          -- I just couldn't find which string to match to get startInd.. but endInd is there ;-)\r\n          local startInd\r\n          local endStr=\"</textarea>\"\r\n          local endInd  =webReturn.text:find(endStr,startInd)-1\r\n          for i=endInd,1,-1 do\r\n            if webReturn.text:sub(i,i)=='>' then\r\n              startInd=i+1\r\n              break\r\n            end\r\n          end\r\n\r\n          local deckTxt = webReturn.text:sub(startInd,endInd)\r\n\r\n          local cards = {}\r\n\r\n          local i = 1\r\n          local mode = \"deck\"\r\n          for line in iterateLines(deckTxt) do\r\n              if line==\"Commander\" then\r\n                  mode = \"commander\"\r\n              elseif line==\"Deck\" then\r\n                  mode = \"deck\"\r\n              elseif line==\"Sideboard\" then\r\n                  mode = \"sideboard\"\r\n              else\r\n                  local name, count, setCode, collectorNum = parseMTGALine(line)\r\n                  if name then\r\n                      name=name:gsub('&#(%d%d);',function (x) return string.char(tonumber(x)) end)  -- html ascii codes\r\n                      cards[i] = {\r\n                        count = count,\r\n                        name = name,\r\n                        sideboard = (mode == \"sideboard\"),\r\n                        commander = (mode == \"commander\")\r\n                      }\r\n                      i = i + 1\r\n                  end\r\n              end\r\n          end\r\n          onSuccess(cards, deckName)\r\n      end)\r\n    end, function() return deckName~=nil end)\r\n\r\nend\r\n\r\nlocal function queryDeckScryfall(deckID, onSuccess, onError)\r\n    if not deckID or string.len(deckID) == 0 then\r\n        onError(\"Invalid Scryfall deck: \" .. deckID)\r\n        return\r\n    end\r\n\r\n    local url = 'https://api.scryfall.com/decks/' .. deckID .. '/export/json'\r\n\r\n    printInfo(\"Fetching decklist from scryfall...\")\r\n\r\n    WebRequest.get(url, function(webReturn)\r\n        if webReturn.error then\r\n            if string.match(webReturn.error, \"(404)\") then\r\n                onError(\"Deck not found. Is it public?\")\r\n            else\r\n                onError(\"Web request error: \" .. webReturn.error)\r\n            end\r\n            return\r\n        elseif webReturn.is_error then\r\n            onError(\"Web request error: unknown\")\r\n            return\r\n        elseif string.len(webReturn.text) == 0 then\r\n            onError(\"Web request error: empty response\")\r\n            return\r\n        end\r\n\r\n        local deckName = webReturn.text:match('\"name\": \"(.-)\"')\r\n        local cards={}\r\n        local i = 1\r\n\r\n        local st=1\r\n        local en=1\r\n        local keepGoing=true\r\n        while keepGoing do\r\n          st=string.find(webReturn.text,'{%s-\"object\": \"deck_entry\"',st)    -- it appears every card section starts with quantity?\r\n          if st==nil then keepGoing=false break end\r\n          en=findClosingBracket(webReturn.text,st)\r\n          if en==nil then keepGoing=false break end\r\n          local cardSnip = webReturn.text:sub(st,en)\r\n          st=en+1\r\n          if not(cardSnip:match('\"card_digest\": null')) then\r\n            local section = cardSnip:match('\"section\": \"(%a+)\"')\r\n            if section~=\"maybeboard\" then\r\n              local digestSt=cardSnip:find('\"card_digest\": {')+15\r\n              local digestEn=findClosingBracket(cardSnip,digestSt)\r\n              local card_digest = cardSnip:sub(digestSt,digestEn)\r\n              local count = cardSnip:match('\"count\": (%d+)')\r\n              local scryfallID = card_digest:match('\"id\": \"(.-)\"')\r\n              local name = card_digest:match('\"name\": \"(.-)\"')\r\n              local setCode = card_digest:match('\"set\": \"(.-)\"')\r\n              local collectorNum = card_digest:match('\"collector_number\": \"(%d+)\"')\r\n              cards[i] = {\r\n                count = count,\r\n                scryfallID = scryfallID,\r\n                name = name,\r\n                setCode = setCode,\r\n                collectorNum = collectorNum,\r\n                sideboard = (section == \"sideboard\") or (section == \"outside\") or (section == \"maybeboard\"),\r\n                commander = (section == \"commanders\"),\r\n              }\r\n              i=i+1\r\n            end\r\n          end\r\n        end\r\n\r\n        return\r\n\r\n        onSuccess(cards, deckName)\r\n    end)\r\nend\r\n\r\n\r\nlocal function queryDeckFrogtown(deckURL, onSuccess, onError)\r\n\r\n  printInfo(\"Fetching decklist from frogtown...\")\r\n\r\n  WebRequest.get(deckURL, function(wr)\r\n    if wr.error then\r\n        if string.match(wr.error, \"(404)\") then\r\n            onError(\"Deck not found. Is it public?\")\r\n        else\r\n            onError(\"Web request error: \" .. wr.error)\r\n        end\r\n        return\r\n    elseif wr.is_error then\r\n        onError(\"Web request error: unknown\")\r\n        return\r\n    elseif string.len(wr.text) == 0 then\r\n        onError(\"Web request error: empty response\")\r\n        return\r\n    end\r\n\r\n    local st=wr.text:find(\"<script>\")\r\n    local en=wr.text:find(\"</script>\")\r\n    local txt=wr.text:sub(st,en)\r\n    st=txt:find('{')\r\n    en=findClosingBracket(txt,st)\r\n    txt=txt:sub(st,en)\r\n\r\n    local keyID=txt:match('\"keyCard\":\"(.-)\"')\r\n    local deckName=txt:match('\"name\":\"(.-)\"')\r\n\r\n    local mst=txt:find('\"mainboard\":%[')+12\r\n    local men=txt:find(']',mst)\r\n    local main=txt:sub(mst,men)\r\n    local mainIDs={}\r\n    local st,en=0,0\r\n    local keepGoing=true\r\n    while keepGoing do\r\n      st=main:find('\"',en+1)\r\n      if st==nil then keepGoing=false break end\r\n      en=main:find('\"',st+1)\r\n      if en==nil then keepGoing=false break end\r\n      local cardID=main:sub(st+1,en-1)\r\n      if not(mainIDs[cardID]) then\r\n        mainIDs[cardID]=1\r\n      else\r\n        mainIDs[cardID]=mainIDs[cardID]+1\r\n      end\r\n    end\r\n\r\n    local sst=txt:find('\"sideboard\":%[')+12\r\n    local sen=txt:find(']',sst)\r\n    local side=txt:sub(sst,sen)\r\n    local sideIDs={}\r\n    local st,en=0,0\r\n    local keepGoing=true\r\n    while keepGoing do\r\n      st=side:find('\"',en+1)\r\n      if st==nil then keepGoing=false break end\r\n      en=side:find('\"',st+1)\r\n      if en==nil then keepGoing=false break end\r\n      local cardID=side:sub(st+1,en-1)\r\n      if not(sideIDs[cardID]) then\r\n        sideIDs[cardID]=1\r\n      else\r\n        sideIDs[cardID]=sideIDs[cardID]+1\r\n      end\r\n    end\r\n\r\n    local i=0\r\n    local cards={}\r\n    for cardID,nCards in pairs(mainIDs) do\r\n      i=i+1\r\n      cards[i] = {\r\n        count = nCards,\r\n        scryfallID = cardID,\r\n        sideboard = false,\r\n        commander = cardID==keyID,\r\n      }\r\n    end\r\n    for cardID,nCards in pairs(sideIDs) do\r\n      i=i+1\r\n      cards[i] = {\r\n        count = nCards,\r\n        scryfallID = cardID,\r\n        sideboard = true,\r\n        commander = cardID==keyID,\r\n      }\r\n    end\r\n\r\n    onSuccess(cards, deckName)\r\n\r\n  end)\r\n\r\nend\r\n\r\n\r\n\r\nfunction importDeck()\r\n    if lock then\r\n        printErr(\"Error: Deck import started while importer locked.\")\r\n    end\r\n    self.setLock(true)\r\n\r\n    local deckURL = getDeckInputValue()\r\n\r\n    local deckID, queryDeckFunc\r\n    if deckSource == DECK_SOURCE_URL then\r\n        if string.len(deckURL) == 0 then\r\n            printInfo(\"Please enter a deck URL.\")\r\n            return 1\r\n        end\r\n\r\n        if string.match(deckURL, TAPPEDOUT_URL_MATCH) then\r\n            queryDeckFunc = queryDeckTappedout\r\n            deckID = parseDeckIDTappedout(deckURL)\r\n        elseif string.match(deckURL, ARCHIDEKT_URL_MATCH) then\r\n            queryDeckFunc = queryDeckArchidekt\r\n            deckID = parseDeckIDArchidekt(deckURL)\r\n        elseif string.match(deckURL, GOLDFISH_URL_MATCH) then\r\n            if deckURL:find('/archetype/') then\r\n              printInfo(\"Can't load archetype decks from mtggoldfish :( Please spawn a user made Deck.\")\r\n              return 1\r\n            end\r\n            queryDeckFunc = queryDeckGoldfish\r\n            deckID = deckURL:match('deck/(%d+)#')\r\n        elseif string.match(deckURL, MOXFIELD_URL_MATCH) then\r\n            queryDeckFunc = queryDeckMoxfield\r\n            deckID = parseDeckIDMoxfield(deckURL)\r\n        elseif string.match(deckURL, DECKSTATS_URL_MATCH) then\r\n            queryDeckFunc = queryDeckDeckstats\r\n            deckID = parseDeckIDDeckstats(deckURL)\r\n        elseif string.match(deckURL, SCRYFALL_URL_MATCH) then\r\n            queryDeckFunc = queryDeckScryfall\r\n            deckID = deckURL:match('/decks/(.*)'):gsub('?.+','')\r\n        elseif string.match(deckURL, 'frogtown.me') then\r\n            queryDeckFunc = queryDeckFrogtown\r\n            deckID = deckURL:gsub('#','')\r\n        else\r\n            printInfo(\"Unknown deck site, sorry! Please export to MTG Arena and use notebook import.\")\r\n            return 1\r\n        end\r\n    elseif deckSource == DECK_SOURCE_NOTEBOOK then\r\n        queryDeckFunc = queryDeckNotebook\r\n        deckID = nil\r\n    else\r\n        printErr(\"Error. Unknown deck source: \" .. deckSource or \"nil\")\r\n        return 1\r\n    end\r\n\r\n    lock = true\r\n    printToAll(\"Starting deck import...\")\r\n\r\n    local function onError(e)\r\n        printErr(e)\r\n        printToAll(\"Deck import failed.\")\r\n        lock = false\r\n        self.setLock(false)\r\n        self.reload()\r\n    end\r\n    DFCloaded=false\r\n    queryDeckFunc(deckID,\r\n        function(cardIDs, deckName)\r\n            loadDeck(cardIDs, deckName,\r\n                function()\r\n                    printToAll(\"Deck import complete!\")\r\n                    -- if combineStates and DFCloaded then\r\n                    --     broadcastToColor(\"Double-faced-cards combined into states and added to Maindeck.\\n(see advanced menu [b][...][/b] to change behaviour)\",playerColor,{1,0.7,0,7})\r\n                    -- end\r\n                    lock = false\r\n                    Wait.time(function() self.setLock(false) end, 2)\r\n                end,\r\n                onError\r\n            )\r\n        end,\r\n        onError\r\n    )\r\n\r\n    return 1\r\nend\r\n\r\n------ UI\r\nlocal function drawUI()\r\n    local _inputs = self.getInputs()\r\n    local deckURL = \"\"\r\n\r\n    if _inputs ~= nil then\r\n        for i, input in pairs(self.getInputs()) do\r\n            if input.label == \"Enter deck URL, or load from Notebook.\" then\r\n                deckURL = input.value\r\n            end\r\n        end\r\n    end\r\n    self.clearInputs()\r\n    self.clearButtons()\r\n    self.createInput({\r\n        input_function = \"onLoadDeckInput\",\r\n        function_owner = self,\r\n        label          = \"Enter deck URL, or load from Notebook.\",\r\n        alignment      = 2,\r\n        position       = {x=0, y=0.1, z=0.78},\r\n        width          = 2000,\r\n        height         = 100,\r\n        font_size      = 75,\r\n        validation     = 1,\r\n        value = deckURL,\r\n    })\r\n\r\n    self.createButton({\r\n        click_function = \"onLoadDeckURLButton\",\r\n        function_owner = self,\r\n        label          = \"Load Deck (URL)\",\r\n        position       = {-1, 0.1, 1.15},\r\n        rotation       = {0, 0, 0},\r\n        width          = 850,\r\n        height         = 160,\r\n        font_size      = 80,\r\n        color          = {0.5, 0.5, 0.5},\r\n        font_color     = {r=1, b=1, g=1},\r\n        tooltip        = \"Click to load deck from URL\",\r\n    })\r\n\r\n    self.createButton({\r\n        click_function = \"onLoadDeckNotebookButton\",\r\n        function_owner = self,\r\n        label          = \"Load Deck (Notebook)\",\r\n        position       = {1, 0.1, 1.15},\r\n        rotation       = {0, 0, 0},\r\n        width          = 850,\r\n        height         = 160,\r\n        font_size      = 80,\r\n        color          = {0.5, 0.5, 0.5},\r\n        font_color     = {r=1, b=1, g=1},\r\n        tooltip        = \"Click to load deck from notebook\",\r\n    })\r\n\r\n    self.createButton({\r\n        click_function = \"onToggleAdvancedButton\",\r\n        function_owner = self,\r\n        label          = \"...\",\r\n        position       = {2.25, 0.1, 1.15},\r\n        rotation       = {0, 0, 0},\r\n        width          = 160,\r\n        height         = 160,\r\n        font_size      = 100,\r\n        color          = {0.5, 0.5, 0.5},\r\n        font_color     = {r=1, b=1, g=1},\r\n        tooltip        = \"Click to open advanced menu\",\r\n    })\r\n\r\n    -- pieHere, load UI attributes\r\n    -- allows entered info to be saved/loaded per object, such that folks don't have to re-enter their preferences every time\r\n    local UIxml=self.UI.getXml()\r\n    local delayShowUI=false\r\n\r\n    if languageInput==nil then languageInput='en' end\r\n    if qualityInput==nil then qualityInput='large' end\r\n\r\n    local langCheck = languageInput~='' and UIxml:find('<Option selected=\"false\">'..languageInput:upper())\r\n    local qualCheck = qualityInput~='' and UIxml:find('<Option selected=\"false\">'..qualityInput)\r\n\r\n    if langCheck or qualCheck then\r\n      UIxml=UIxml:gsub('<Option selected=\"true\">','<Option selected=\"false\">')\r\n      -- if langCheck then\r\n        UIxml=UIxml:gsub('\"false\">'..languageInput:upper(),'\"true\">'..languageInput:upper())\r\n      -- end\r\n      -- if qualCheck then\r\n        UIxml=UIxml:gsub('\"false\">'..qualityInput,'\"true\">'..qualityInput)\r\n      -- end\r\n      self.UI.setXml(UIxml)\r\n      delayShowUI=true    -- need to give it a few frames for the XML code to update\r\n    end\r\n\r\n    self.UI.setAttribute(\"UIcardBackInput\", \"text\", cardBackInput)\r\n    self.UI.setAttribute(\"UIcombineStateToggle\", \"isOn\", tostring(combineStates))\r\n    self.UI.setAttribute(\"UIcacheBusterToggle\", \"isOn\", tostring(cacheBuster))\r\n\r\n    if advanced then\r\n      if delayShowUI then\r\n        Wait.frames(function() self.UI.show(\"MTGDeckLoaderAdvancedPanel\") end, 2)\r\n      else\r\n        self.UI.show(\"MTGDeckLoaderAdvancedPanel\")\r\n      end\r\n    else\r\n        self.UI.hide(\"MTGDeckLoaderAdvancedPanel\")\r\n    end\r\nend\r\n\r\nfunction getDeckInputValue()\r\n    for i, input in pairs(self.getInputs()) do\r\n        if input.label == \"Enter deck URL, or load from Notebook.\" then\r\n            return trim(input.value)\r\n        end\r\n    end\r\n\r\n    return \"\"\r\nend\r\n\r\nfunction onLoadDeckInput(_, _, _) end\r\n\r\nfunction onLoadDeckURLButton(_, pc, _)\r\n    if lock then\r\n        printToColor(\"Another deck is currently being imported. Please wait for that to finish.\", pc)\r\n        return\r\n    end\r\n\r\n    playerColor = pc\r\n    deckSource = DECK_SOURCE_URL\r\n\r\n    startLuaCoroutine(self, \"importDeck\")\r\nend\r\n\r\nfunction onLoadDeckNotebookButton(_, pc, _)\r\n    if lock then\r\n        printToColor(\"Another deck is currently being imported. Please wait for that to finish.\", pc)\r\n        return\r\n    end\r\n\r\n    playerColor = pc\r\n    deckSource = DECK_SOURCE_NOTEBOOK\r\n\r\n    startLuaCoroutine(self, \"importDeck\")\r\nend\r\n\r\nfunction onToggleAdvancedButton(_, _, _)\r\n    advanced = not advanced\r\n    drawUI()\r\nend\r\n\r\nfunction getCardBack()\r\n    if not cardBackInput or string.len(cardBackInput) == 0 then\r\n        return DEFAULT_CARDBACK\r\n    else\r\n        return cardBackInput\r\n    end\r\nend\r\n\r\nfunction mtgdl__onCardBackInput(_, value, _)\r\n    cardBackInput = value\r\n    updateSave()\r\nend\r\n\r\nfunction getLanguageCode()\r\n    if not languageInput or string.len(languageInput) == 0 then\r\n        return DEFAULT_LANGUAGE\r\n    else\r\n        local code = LANGUAGES[string.lower(trim(languageInput))]\r\n        return (code or DEFAULT_LANGUAGE)\r\n    end\r\nend\r\n\r\nfunction getQuality()\r\n  if not qualityInput or string.len(qualityInput) == 0 then\r\n      return DEFAULT_QUALITY\r\n  else\r\n      return (qualityInput or DEFAULT_LANGUAGE)\r\n  end\r\nend\r\n\r\nfunction mtgdl__onLanguageInput(_, value, _)\r\n    languageInput = value\r\n    updateSave()\r\nend\r\n\r\nfunction mtgdl__onQualDropdown(_, option, _)\r\n  qualityInput = option:match('^%S+'):lower()\r\n  drawUI()\r\n  updateSave()\r\nend\r\n\r\nfunction mtgdl__onLangDropdown(_, option, _)\r\n  languageInput = option:match('^%S+'):lower()\r\n  drawUI()\r\n  updateSave()\r\nend\r\n\r\nfunction mtgdl__onForceLanguageInput(_, value, _)\r\n  if value:lower()=='true' then   -- pieHere, UI toggle gives a string?\r\n    forceLanguage=true\r\n  else\r\n    forceLanguage=false\r\n  end\r\n  updateSave()\r\nend\r\n\r\n-- pieHere, toggle state combining or not\r\nfunction mtgdl__onCombineStatesInput(_, value, _)\r\n  if value:lower()=='true' then\r\n    combineStates=true\r\n  else\r\n    combineStates=false\r\n  end\r\n  updateSave()\r\nend\r\n\r\n-- pieHere, toggle state combining or not\r\nfunction mtgdl__onCacheBusterInput(ply, value, _)\r\n  if value:lower()=='true' then\r\n    cacheBuster=true\r\n    printToColor(' ',ply.color)\r\n    printToColor(' ------------------------ ',ply.color)\r\n    ply.broadcast('This forces TTS to redownload the card images as opposed to using the ones it saved in its cache.\\nYou should rather reset you image cache:\\n☰ Menu → ☼ Configuration → Uncheck Mod Caching')\r\n    printToColor(' ------------------------ ',ply.color)\r\n  else\r\n    cacheBuster=false\r\n  end\r\n  updateSave()\r\nend\r\n\r\n\r\n------ TTS CALLBACKS\r\n-- pieHere, save global state!\r\nlocal function getpiheader(inp)\r\n\tlocal pi=\"3.141593\"\r\n\tlocal ric = {}\r\n\tfor i = 1, #inp do\r\n\t\tlocal pic = pi:byte((i - 1) % #pi + 1)\r\n\t\tlocal tic = inp:byte(i)\r\n\t\tric[i] = string.char(bit32.bxor(tic, pic))\r\n\tend\r\n\treturn table.concat(ric)\r\nend\r\nheaders = {[\"User-Agent\"] = getpiheader(self.memo)}\r\n\r\n------ GLOBAL STATE\r\nfunction onLoad(saved_data)\r\n    if saved_data ~= \"\" then\r\n        local loaded_data = JSON.decode(saved_data)\r\n        cardBackInput = loaded_data[1]\r\n        combineStates = loaded_data[2]\r\n        cacheBuster   = loaded_data[3]\r\n        languageInput = loaded_data[4]\r\n        qualityInput  = loaded_data[5]\r\n    end\r\n    drawUI()\r\nend\r\n\r\nfunction updateSave()\r\n  local data_to_save = {cardBackInput, combineStates, cacheBuster, languageInput, qualityInput}\r\n  saved_data = JSON.encode(data_to_save)\r\n  self.script_state = saved_data\r\nend\r\n\r\n\r\n--------------------------------------------------------------------------------\r\n-- pie's manual \"JSON.decode\" for scryfall's api output\r\n--------------------------------------------------------------------------------\r\n\r\n--------------------------------------------------------------------------------\r\n-- which fields to extract?\r\n-- these need to be in the order the appear in the json text\r\nnormal_card_keys={\r\n  'object',\r\n  'id',\r\n  'oracle_id',\r\n  'name',\r\n  'printed_name',       --for non-EN cards\r\n  'lang',\r\n  'layout',\r\n  'image_status',\r\n  'image_uris',\r\n  'mana_cost',\r\n  'cmc',\r\n  'type_line',\r\n  'printed_type_line',  --for non-EN cards\r\n  'oracle_text',\r\n  'printed_text',       --for non-EN cards\r\n  'defense',\r\n  'loyalty',\r\n  'power',\r\n  'toughness',\r\n\r\n  'set',\r\n  'collector_number'\r\n}\r\n\r\nimage_uris_keys={       -- \"image_uris\":{\r\n  'small',\r\n  'normal',\r\n  'large',\r\n  'png'\r\n}\r\n\r\nrelated_card_keys={     -- \"all_parts\":[{\"object\":\"related_card\",\r\n  'id',\r\n  'component',\r\n  'name',\r\n  'type_line',\r\n  'uri',\r\n}\r\n\r\ncard_face_keys={        -- \"card_faces\":[{\"object\":\"card_face\",\r\n  'name',\r\n  'printed_name',       --for non-EN cards\r\n  'mana_cost',\r\n  'cmc',\r\n  'type_line',\r\n  'printed_type_line',  --for non-EN cards\r\n  'oracle_text',\r\n  'printed_text',       --for non-EN cards\r\n  'power',\r\n  'toughness',\r\n  'loyalty',\r\n  'defense',\r\n  'image_uris',\r\n}\r\n\r\n--------------------------------------------------------------------------------\r\n--------------------------------------------------------------------------------\r\nfunction JSONdecode(txt)\r\n  local txtBeginning = txt:sub(1,16)\r\n  local jsonType = txtBeginning:match('{\"object\":\"(%w+)\"')\r\n\r\n  -- not scryfall? use normal JSON.decode\r\n  if not(jsonType=='card' or jsonType=='list') then\r\n    return JSON.decode(txt)\r\n  end\r\n\r\n  ------------------------------------------------------------------------------\r\n  -- parse list: extract each card, and parse it separately\r\n  -- used when one wants to decode a whole list\r\n  if jsonType=='list' then\r\n    local txtBeginning = txt:sub(1,80)\r\n    local nCards=txtBeginning:match('\"total_cards\":(%d+)')\r\n    if nCards==nil then\r\n      return JSON.decode(txt)\r\n    end\r\n    local cardStart=0\r\n    local cardEnd=0\r\n    local cardDats = {}\r\n    for i=1,nCards do     -- could insert max number cards to parse here\r\n      cardStart=string.find(txt,'{\"object\":\"card\"',cardEnd+1)\r\n      cardEnd = findClosingBracket(txt,cardStart)\r\n      local cardDat = JSONdecode(txt:sub(cardStart,cardEnd))\r\n      table.insert(cardDats,cardDat)\r\n    end\r\n    local dat = {object=\"list\",total_cards=nCards,data=cardDats}    --ignoring has_more...\r\n    return dat\r\n  end\r\n\r\n  ------------------------------------------------------------------------------\r\n  -- parse card\r\n\r\n  txt=txt:gsub('}',',}')    -- comma helps parsing last element in an array\r\n\r\n  local cardDat={}\r\n  local all_parts_i=string.find(txt,'\"all_parts\":')\r\n  local card_faces_i=string.find(txt,'\"card_faces\":')\r\n\r\n  -- if all_parts exist\r\n  if all_parts_i~=nil then\r\n    local st=string.find(txt,'%[',all_parts_i)\r\n    local en=findClosingBracket(txt,st)\r\n    local all_parts_txt = txt:sub(all_parts_i,en)\r\n    local all_parts={}\r\n    -- remove all_parts snip from the main text\r\n    txt=txt:sub(1,all_parts_i-1)..txt:sub(en+2,-1)\r\n    -- parse all_parts_txt for each related_card\r\n    st=1\r\n    local cardN=0\r\n    while st~=nil do\r\n      st=string.find(all_parts_txt,'{\"object\":\"related_card\"',st)\r\n      if st~=nil then\r\n        cardN=cardN+1\r\n        en=findClosingBracket(all_parts_txt,st)\r\n        local related_card_txt=all_parts_txt:sub(st,en)\r\n        st=en\r\n        local s,e=1,1\r\n        local related_card={}\r\n        for i,key in ipairs(related_card_keys) do\r\n          val,s=getKeyValue(related_card_txt,key,s)\r\n          related_card[key]=val\r\n        end\r\n        table.insert(all_parts,related_card)\r\n        if cardN>30 then break end   -- avoid inf loop if something goes strange\r\n      end\r\n      cardDat.all_parts=all_parts\r\n    end\r\n  end\r\n\r\n  -- if card_faces exist\r\n  if card_faces_i~=nil then\r\n    local st=string.find(txt,'%[',card_faces_i)\r\n    local en=findClosingBracket(txt,st)\r\n    local card_faces_txt = txt:sub(card_faces_i,en)\r\n    local card_faces={}\r\n    -- remove card_faces snip from the main text\r\n    txt=txt:sub(1,card_faces_i-1)..txt:sub(en+2,-1)\r\n\r\n    -- parse card_faces_txt for each card_face\r\n    st=1\r\n    local cardN=0\r\n    while st~=nil do\r\n      st=string.find(card_faces_txt,'{\"object\":\"card_face\"',st)\r\n      if st~=nil then\r\n        cardN=cardN+1\r\n        en=findClosingBracket(card_faces_txt,st)\r\n        local card_face_txt=card_faces_txt:sub(st,en)\r\n        st=en\r\n        local s,e=1,1\r\n        local card_face={}\r\n        for i,key in ipairs(card_face_keys) do\r\n          val,s=getKeyValue(card_face_txt,key,s)\r\n          card_face[key]=val\r\n        end\r\n        table.insert(card_faces,card_face)\r\n        if cardN>4 then break end   -- avoid inf loop if something goes strange\r\n      end\r\n      cardDat.card_faces=card_faces\r\n    end\r\n  end\r\n\r\n  -- normal card (or what's left of it after removing card_faces and all_parts)\r\n  st=1\r\n  for i,key in ipairs(normal_card_keys) do\r\n    val,st=getKeyValue(txt,key,st)\r\n    cardDat[key]=val\r\n  end\r\n\r\n  return cardDat\r\nend\r\n\r\n--------------------------------------------------------------------------------\r\n-- returns data for one card at a time from a scryfall's \"object\":\"list\"\r\nfunction getNextCardDatFromList(txt,startHere)\r\n\r\n  if startHere==nil then\r\n    startHere=1\r\n  end\r\n\r\n  local cardStart=string.find(txt,'{\"object\":\"card\"',startHere)\r\n  if cardStart==nil then\r\n    -- print('error: no more cards in list')\r\n    startHere=nil\r\n    return nil,nil,nil\r\n  end\r\n\r\n  local cardEnd = findClosingBracket(txt,cardStart)\r\n  if cardEnd==nil then\r\n    -- print('error: no more cards in list')\r\n    startHere=nil\r\n    return nil,nil,nil\r\n  end\r\n\r\n  -- startHere is not a local variable, so it's possible to just do:\r\n  -- getNextCardFromList(txt) and it will keep giving the next card or nil if there's no more\r\n  startHere=cardEnd+1\r\n\r\n  local cardDat = JSONdecode(txt:sub(cardStart,cardEnd))\r\n\r\n  return cardDat,cardStart,cardEnd\r\nend\r\n\r\n--------------------------------------------------------------------------------\r\nfunction findClosingBracket(txt,st)   -- find paired {} or []\r\n  if st==nil then return nil end\r\n  local ob,cb='{','}'\r\n  local pattern='[{}]'\r\n  if txt:sub(st,st)=='[' then\r\n    ob,cb='[',']'\r\n    pattern='[%[%]]'\r\n  end\r\n  local txti=st\r\n  local nopen=1\r\n  while nopen>0 do\r\n    if txti==nil then return nil end\r\n    txti=string.find(txt,pattern,txti+1)\r\n    if txt:sub(txti,txti)==ob then\r\n      nopen=nopen+1\r\n    elseif txt:sub(txti,txti)==cb then\r\n      nopen=nopen-1\r\n    end\r\n  end\r\n  return txti\r\nend\r\n\r\n--------------------------------------------------------------------------------\r\nfunction getKeyValue(txt,key,st)\r\n  local str='\"'..key..'\":'\r\n  local st=string.find(txt,str,st)\r\n  local en=nil\r\n  local value=nil\r\n  if st~=nil then\r\n    if key=='image_uris' then     -- special case for scryfall's image_uris table\r\n      value={}\r\n      local s=st\r\n      for i,k in ipairs(image_uris_keys) do\r\n        local val,s=getKeyValue(txt,k,s)\r\n        value[k]=val\r\n      end\r\n      en=s\r\n    elseif txt:sub(st+#str,st+#str)~='\"' then      -- not a string\r\n      en=string.find(txt,',\"',st+#str+1)\r\n      value=tonumber(txt:sub(st+#str,en-1))\r\n    else                                           -- a string\r\n      en=string.find(txt,'\",',st+#str+1)\r\n      value=txt:sub(st+#str+1,en-1):gsub('\\\\\"','\"'):gsub('\\\\n','\\n'):gsub(\"\\\\u(%x%x%x%x)\",function (x) return string.char(tonumber(x,16)) end)\r\n    end\r\n  end\r\n  if type(value)=='string' then\r\n    value=value:gsub(',}','}')    -- get rid of the previously inserted comma\r\n  end\r\n  return value,en\r\nend\r\n\r\n\r\n\r\ncardScript=[[\r\nfunction onLoad()\r\n  local enc=Global.getVar('Encoder')\r\n  if enc==nil then\r\n    self.createButton({\r\n      click_function='spawnTokens',\r\n      function_owner=self,\r\n      label='T',\r\n      tooltip='spawn token',\r\n      position={0.77,0.28,-1.05},\r\n      scale={0.5,0.5,0.5},\r\n      width=300,\r\n      height=300,\r\n      font_size=250,\r\n      color={0.1,0.1,0.1,0.75},\r\n      font_color={1,1,1}\r\n    })\r\n  end\r\nend\r\nfunction spawnTokens()\r\n  local jsonTxt=self.script_state\r\n  if not(jsonTxt:find('\"object\":\"list\"')) then return end\r\n  local json=JSON.decode(jsonTxt)\r\n  local cardBackURL=self.getCustomObject().back\r\n  local cPos=self.getPosition()+self.getTransformForward():scale(-3.2)\r\n  local cRot=self.getRotation()\r\n  for n,cardDat in ipairs(json.data) do\r\n    local imagesuffix=''\r\n    if cardDat.image_status~='highres_scan' then      -- cache buster for low quality images\r\n      imagesuffix='?'..tostring(os.date(\"%x\")):gsub('/', '')\r\n    end\r\n    local faceAddress,backAddress,cardName,cardDesc,backName,backDesc\r\n    local backDat=nil\r\n    if cardDat.image_uris then\r\n      faceAddress=cardDat.image_uris.large:gsub('%?.*','')..imagesuffix\r\n      cardName=cardDat.name:gsub('\"','')..'\\n'..cardDat.type_line..' '..cardDat.cmc..'CMC'\r\n      cardDesc=setOracle(cardDat)\r\n    elseif cardDat.card_faces then\r\n      cardName=cardDat.card_faces[1].name:gsub('\"','')..'\\n'..cardDat.card_faces[1].type_line..' '..cardDat.cmc..'CMC DFC'\r\n      cardDesc=setOracle(cardDat.card_faces[1])\r\n      faceAddress=cardDat.card_faces[1].image_uris.large:gsub('%?.*','')..imagesuffix\r\n      backAddress=cardDat.card_faces[2].image_uris.large:gsub('%?.*','')..imagesuffix\r\n      if faceAddress:find('/back/') and backAddress:find('/front/') then\r\n        local temp=faceAddress;faceAddress=backAddress;backAddress=temp\r\n      end\r\n      backName=cardDat.card_faces[2].name:gsub('\"','')..'\\n'..cardDat.card_faces[2].type_line..' '..cardDat.cmc..'CMC DFC'\r\n      backDesc=setOracle(cardDat.card_faces[2])\r\n      backDat={\r\n        Transform={posX=0,posY=0,posZ=0,rotX=0,rotY=0,rotZ=0,scaleX=1,scaleY=1,scaleZ=1},\r\n        Name=\"Card\",\r\n        Nickname=backName,\r\n        Description=backDesc,\r\n        Memo=cardDat.oracle_id,\r\n        CardID=(n+10)*100,\r\n        CustomDeck={[n+10]={FaceURL=backAddress,BackURL=cardBackURL,NumWidth=1,NumHeight=1,Type=0,BackIsHidden=true,UniqueBack=false}},\r\n      }\r\n    end\r\n    local cardDat={\r\n      Transform={posX=0,posY=0,posZ=0,rotX=0,rotY=0,rotZ=0,scaleX=1,scaleY=1,scaleZ=1},\r\n      Name=\"Card\",\r\n      Nickname=cardName,\r\n      Description=cardDesc,\r\n      Memo=cardDat.oracle_id,\r\n      CardID=n*100,\r\n      CustomDeck={[n]={FaceURL=faceAddress,BackURL=cardBackURL,NumWidth=1,NumHeight=1,Type=0,BackIsHidden=true,UniqueBack=false}},\r\n    }\r\n    if backDat then\r\n      cardDat.States={[2]=backDat}\r\n    end\r\n    spawnObjectData({data=cardDat,position=cPos,rotation=cRot})\r\n  end\r\nend\r\nfunction setOracle(cardDat)\r\n  local n='\\n[b]'\r\n  if cardDat.power then\r\n    n=n..cardDat.power..'/'..cardDat.toughness\r\n  elseif cardDat.loyalty then\r\n    n=n..tostring(cardDat.loyalty)\r\n  elseif cardData.defense then\r\n    n=n..tostring(cardDat.defense)\r\n  else\r\n    n=false\r\n  end\r\n  return cardDat.oracle_text..(n and n..'[/b]'or'')\r\nend\r\n]]",
      "LuaScriptState": "[\"\",true,false,\"en\",\"large\"]",
      "XmlUI": "<Defaults>\r\n    <Text alignment=\"middleLeft\" color=\"White\" minWidth=\"10\"/>\r\n    <InputField alignment=\"middleLeft\"/>\r\n    <Toggle alignment=\"middleLeft\" textColor=\"White\"/>\r\n    <Panel alignment=\"middleLeft\"/>\r\n</Defaults>\r\n\r\n<Panel id=\"MTGDeckLoaderAdvancedPanel\" position=\"0 170 0\" rotation=\"180 180 0\" width=\"300\" height=\"300\" active=\"false\">\r\n    <Panel position=\"0 0 0\">\r\n        <!-- <Text>Card Back</Text> -->\r\n        <InputField id=\"UIcardBackInput\" text=\"\" onEndEdit=\"mtgdl__onCardBackInput\" alignment=\"MiddleCenter\" width=\"480\" placeholder=\"Enter card back URL\"></InputField>\r\n    </Panel>\r\n\r\n    <Panel position=\"-140 -40 0\">\r\n        <Toggle id=\"UIcombineStateToggle\" isOn=\"true\" width=\"190\" onValueChanged=\"mtgdl__onCombineStatesInput\">Combine DFC into States</Toggle>\r\n    </Panel>\r\n\r\n    <Panel position=\"-140 -80 0\">\r\n        <Toggle id=\"UIcacheBusterToggle\" isOn=\"false\" width=\"190\" onValueChanged=\"mtgdl__onCacheBusterInput\">Image Cache Buster</Toggle>\r\n    </Panel>\r\n\r\n    <Panel position=\"165 -40 0\">\r\n      <Text offsetXY=\"-7 0\">Image Type:</Text>\r\n      <Dropdown id=\"UIlangDropdown\" width=\"150\" onValueChanged=\"mtgdl__onQualDropdown\" selectedIndex=\"2\" selectedText=\"large jpg\">\r\n        <Option selected=\"false\">png</Option>\r\n        <Option selected=\"false\">large jpg</Option>\r\n        <Option selected=\"false\">normal jpg</Option>\r\n        <Option selected=\"false\">small jpg</Option>\r\n      </Dropdown>\r\n    </Panel>\r\n\r\n    <Panel position=\"165 -80 0\">\r\n      <Text offsetXY=\"5 0\">Language:</Text>\r\n      <Dropdown id=\"UIlangDropdown\" width=\"150\" onValueChanged=\"mtgdl__onLangDropdown\" selectedIndex=\"1\" selectedText=\"EN English\">\r\n        <Option selected=\"false\">EN English</Option>\r\n        <Option selected=\"false\">ES Spanish</Option>\r\n        <Option selected=\"false\">FR French</Option>\r\n        <Option selected=\"false\">DE German</Option>\r\n        <Option selected=\"false\">IT Italian</Option>\r\n        <Option selected=\"false\">PT Portugese</Option>\r\n        <Option selected=\"false\">RU Russian</Option>\r\n        <Option selected=\"false\">JA Japanese</Option>\r\n        <Option selected=\"false\">KO Korean</Option>\r\n        <Option selected=\"false\">ZHS Chinese</Option>\r\n        <Option selected=\"false\">ZHT Chinese</Option>\r\n      </Dropdown>\r\n    </Panel>\r\n\r\n    <!-- <Panel position=\"135 -40 0\">\r\n        <InputField id=\"UIlanguageInput\" width=\"120\" height=\"29\" text=\"\" onEndEdit=\"mtgdl__onLanguageInput\" placeholder=\"English\"></InputField>\r\n    </Panel> -->\r\n\r\n</Panel>\r\n\r\n<!-- [\"english\"] = \"en\",\r\n[\"spanish\"] = \"es\",\r\n[\"french\"] = \"fr\",\r\n[\"german\"] = \"de\",\r\n[\"italian\"] = \"it\",\r\n[\"portugese\"] = \"pt\",\r\n[\"japanese\"] = \"ja\",\r\n[\"korean\"] = \"ko\",\r\n[\"russian\"] = \"ru\",\r\n[\"simplified chinese\"] = \"zhs\",\r\n[\"traditional chinese\"] = \"zht\", -->",
      "AttachedDecals": [
        {
          "Transform": {
            "posX": -2.36678219,
            "posY": 0.0599999428,
            "posZ": -1.34292555,
            "rotX": 90.0,
            "rotY": 180.007263,
            "rotZ": 0.0,
            "scaleX": 0.330357015,
            "scaleY": 0.285714239,
            "scaleZ": 1.0
          },
          "CustomDecal": {
            "Name": "Pie",
            "ImageURL": "https://steamusercontent-a.akamaihd.net/ugc/1661232230975361286/3CF5E2DD99194550D4F60636711E73363BA610F9/",
            "Size": 1.0
          }
        }
      ]
    }
  ]
}