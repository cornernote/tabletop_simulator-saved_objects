{
  "SaveName": "",
  "Date": "",
  "VersionNumber": "",
  "GameMode": "",
  "GameType": "",
  "GameComplexity": "",
  "Tags": [],
  "Gravity": 0.5,
  "PlayArea": 0.5,
  "Table": "",
  "Sky": "",
  "Note": "",
  "TabStates": {},
  "LuaScript": "",
  "LuaScriptState": "",
  "XmlUI": "",
  "ObjectStates": [
    {
      "GUID": "3d9252",
      "Name": "Custom_Token",
      "Transform": {
        "posX": -11.0449963,
        "posY": 1.01000035,
        "posZ": -1.89000607,
        "rotX": -5.11974569E-08,
        "rotY": -3.89122433E-05,
        "rotZ": -2.89941653E-07,
        "scaleX": 0.69,
        "scaleY": 1.0,
        "scaleZ": 0.692020833
      },
      "Nickname": "Deck Manipulator 2.1",
      "Description": "Workshop: https://steamcommunity.com/sharedfiles/filedetails/?id=3471983770",
      "GMNotes": "",
      "AltLookAngle": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
      },
      "ColorDiffuse": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": false,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "CustomImage": {
        "ImageURL": "https://steamusercontent-a.akamaihd.net/ugc/14826947761443142467/4E8D98E589DB56D037AA3503697CE69B3826DC93/",
        "ImageSecondaryURL": "",
        "ImageScalar": 1.0,
        "WidthScale": 0.0,
        "CustomToken": {
          "Thickness": 0.1,
          "MergeDistancePixels": 15.0,
          "StandUp": false,
          "Stackable": false
        }
      },
      "LuaScript": "--[[\r\n\r\nCreator/Adapter: 55tremine\r\nWorkshop: 3471983770\r\n\r\nContributors:\r\n\tUses code from Amuzet / adapted by π for Deck Lister\r\n\tCode for sorter heavily adapted from workshop 2466086182 by Nyhilo\r\n\tUses code from Deck Layout Tool from workshop 1159463997 by MrStump\r\n\r\nDate: sometime before 2025\r\n\r\nNotes:\r\nKnown error: duplicate GUIDs might mess up\r\n\r\nscryfall mtg card x: 2.19874382019043\r\nscryfall mtg card y: 3.06247329711914\r\n\r\npi table card spacing: 2.35, 3.24\r\ndiff: 0.1513, 0.177527\r\n\r\n]]--\r\n\r\nmod_name='Deck Manipulator'\r\nversion='2.1'\r\n\r\n-------------\r\n-- Globals --\r\n-------------\r\n\r\n-- These offsets are for mtg card grids. Thats why its a weird ratio. Feel free to modify\r\nxDirection = 1\r\nxInitialOffset = -1.25\r\nxIncrementOffset = -0.1513\r\nzIncrementOffset = 0.177527\r\nmaxZOffset = 6--zIncrementOffset*5*-1\r\n\r\ntimeDelay = 0.05\r\n\r\nsortByStrings = {\r\n\t\"By Type\", -- 1\r\n\t\"By Subtype\",\r\n\t\"By CMC\"\r\n}\r\n\r\nsortByData = {\r\n\t{str=\"By Type\", dimensions=1},\r\n\t{str=\"By Subtype\", dimensions=2},\r\n\t{str=\"By CMC\", dimensions=1},\r\n}\r\n\r\nsearchText = \"\"\r\n\r\nfunction nullFunc() end\r\n\r\nfunction onSave()\r\n    saved_data = JSON.encode(layoutData)\r\n    return saved_data\r\nend\r\n\r\nfunction onLoad(saved_data)\r\n\tself.setName(mod_name..\" \"..version)\r\n\tself.setDescription(\"Workshop: https://steamcommunity.com/sharedfiles/filedetails/?id=3471983770\")\r\n\r\n\tif saved_data ~= \"\" then\r\n        layoutData = JSON.decode(saved_data)\r\n\tend\r\n\t\r\n    if (layoutData == nil) then\r\n        layoutData = { cols = 5, rows = 0, sortBy = 0 }\r\n    end\r\n\t\r\n\tlocal buttonStuff = {\r\n\t\tfunction_owner = self,\r\n\t\tposition = {0, 0, 2.8},\r\n\t\twidth = 200,\r\n\t\theight = 200,\r\n\t\tfont_size = 150\r\n\t}\r\n\t\r\n\tfunction directionSet() \r\n\t\txDirection = xDirection * -1\r\n\t\tif (xDirection == -1) then self.editButton({index=0,label=\"<---\"})\r\n\t\telse self.editButton({index=0,label=\"--->\"}) end\r\n\t\t\r\n\tend\r\n\tself.createButton({\r\n\t\tfunction_owner=self, click_function = 'directionSet', tooltip=\"Output Direction\", label=\"--->\",\r\n\t\tposition={0, 0.1, 2}, height=175, width=500,\r\n        font_size=150,\r\n\t})\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] - 1.2\r\n\tbuttonStuff.click_function = 'nullFunc'\r\n\tbuttonStuff.label = \"↔\"\r\n\tbuttonStuff.tooltip = \"\"\r\n\tself.createButton(buttonStuff)\r\n\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 0.55\r\n\tfunction colsInput(obj, playerColor, userInput, stillEditing, layoutKey) layoutData.cols = tonumber(userInput) end\r\n\tself.createInput({\r\n        input_function=\"colsInput\", function_owner=self, tooltip=\"Columns - 0 for infinite\",\r\n        alignment=3, position=buttonStuff.position, height=175, width=350,\r\n        font_size=150, validation=2, tab=2, value=layoutData.cols\r\n    })\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 0.56\r\n\tbuttonStuff.click_function = 'nullFunc'\r\n\tbuttonStuff.label = \"↕\"\r\n\tbuttonStuff.tooltip = \"\"\r\n\tself.createButton(buttonStuff)\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 0.55\r\n\tfunction rowsInput(obj, playerColor, userInput, stillEditing, layoutKey) layoutData.rows = tonumber(userInput) end\r\n\tself.createInput({\r\n        input_function=\"rowsInput\", function_owner=self, tooltip=\"Rows - 0 for infinite\",\r\n        alignment=3, position=buttonStuff.position, height=175, width=350,\r\n        font_size=150, validation=2, tab=2, value=layoutData.rows\r\n    })\r\n\t\r\n\tbuttonStuff.height = 300\r\n\tbuttonStuff.font_size = 250\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 0.7\r\n\tbuttonStuff.width = 300\r\n\tbuttonStuff.click_function = 'layoutCards'\r\n\tbuttonStuff.label = '►'\r\n\tbuttonStuff.tooltip = \"Lay out the cards in a grid Right: Face Down\"\r\n\tself.createButton(buttonStuff)\r\n\r\n\tbuttonStuff.position[1] = 0\r\n\tbuttonStuff.width = 1400\r\n\t\r\n\tbuttonStuff.click_function = 'listCards'\r\n\tbuttonStuff.label = 'List Cards'\r\n\tbuttonStuff.tooltip = \"List the cards to notebook\"\r\n\tbuttonStuff.position[3] = buttonStuff.position[3] + 0.7\r\n\tself.createButton(buttonStuff)\r\n\r\n\tbuttonStuff.click_function = 'alphabetize'\r\n\tbuttonStuff.label = 'Alphabetize'\r\n\tbuttonStuff.tooltip = \"Sort Alphabetically\"\r\n\tbuttonStuff.position[3] = buttonStuff.position[3] + 0.7\r\n\tself.createButton(buttonStuff)\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] - 0.86\r\n\tbuttonStuff.position[3] = buttonStuff.position[3] + 0.7\r\n\tself.createButton({\r\n\t\tfunction_owner = buttonStuff.function_owner,\r\n\t\tclick_function = 'sortByType',\r\n\t\tlabel = 'Sort',\r\n\t\ttooltip = \"Intended only for scryfall MTG cards\",\r\n\t\tposition = buttonStuff.position,\r\n\t\twidth = 550,\r\n\t\theight = buttonStuff.height,\r\n\t\tfont_size = buttonStuff.font_size\r\n\t})\r\n\t\r\n\tif (layoutData.sortBy == nil) then layoutData.sortBy = 1 end\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 1.45\r\n\tself.createButton({\r\n\t\tfunction_owner = buttonStuff.function_owner,\r\n\t\tclick_function = 'sortByScroll',\r\n\t\tlabel = sortByStrings[layoutData.sortBy],\r\n\t\ttooltip = \"\",\r\n\t\tposition = buttonStuff.position,\r\n\t\twidth = 800,\r\n\t\theight = buttonStuff.height,\r\n\t\tfont_size = 150\r\n\t})\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] - 1.55\r\n\tbuttonStuff.position[3] = buttonStuff.position[3] + 0.7\r\n\tself.createButton({\r\n\t\tfunction_owner = buttonStuff.function_owner,\r\n\t\tclick_function = 'findByText',\r\n\t\tlabel = 'Find',\r\n\t\ttooltip = \"Gets ALL cards that match the text in either name or description\",\r\n\t\tposition = buttonStuff.position,\r\n\t\twidth = 450,\r\n\t\theight = buttonStuff.height,\r\n\t\tfont_size = 175\r\n\t})\r\n\t\r\n\tbuttonStuff.position[1] = buttonStuff.position[1] + 1.4\r\n\tfunction searchTextFun(obj, playerColor, userInput, stillEditing, layoutKey) searchText = (userInput) end\r\n\tself.createInput({\r\n        input_function=\"searchTextFun\", function_owner=self, tooltip=\"Search Text (desc and title)\",\r\n        alignment=2, position=buttonStuff.position, height=225, width=900,\r\n        font_size=100, validation=1, tab=2, value=\"\"\r\n    })\r\n\t\r\n\t\r\n    \r\nend\r\n\r\n\r\n-----------\r\n-- Utils --\r\n-----------\r\n\r\nfunction string:split(sep)\r\n    if sep == nil then return {self} end\r\n    local result = {}\r\n    local regex = (\"([^%s]+)\"):format(sep)\r\n    for each in self:gmatch(regex) do\r\n       table.insert(result, each)\r\n    end\r\n    return result\r\nend\r\n\r\n-- Generated by AI. Was too lazy to do it.\r\nfunction rotateAroundPoint(point, endPoint, rotation)\r\n  -- Ensure the rotation is within the valid range (0-360 degrees)\r\n  rotation = rotation % 360\r\n  local radians = math.rad(rotation)\r\n\r\n  -- Translate the endPoint so that the point becomes the origin\r\n  local translatedX = endPoint[1] - point[1]\r\n  local translatedZ = endPoint[3] - point[3]\r\n\r\n  -- Perform the rotation in the XZ plane (reversed direction)\r\n  local rotatedX = translatedX * math.cos(radians) + translatedZ * math.sin(radians)\r\n  local rotatedZ = -translatedX * math.sin(radians) + translatedZ * math.cos(radians)\r\n\r\n  -- Translate the rotated point back to its original position relative to the 'point'\r\n  local finalX = rotatedX + point[1]\r\n  local finalZ = rotatedZ + point[3]\r\n\r\n  -- Return the rotated point, keeping the original Y coordinate\r\n  return {finalX, endPoint[2], finalZ}\r\nend\r\n\r\n------------------\r\n-- The Business --\r\n------------------\r\n\r\n-- putting it in one object since each button uses most of these\r\nfunction getRunData(player_clicker_color, skipGuids)\r\n\tlocal runData = {}\r\n\trunData.pos = self.getPosition()\r\n\trunData.rot = self.getRotation()\r\n\t\r\n\trunData.deck = getContainer(runData.pos)\r\n\tif (runData.deck == nil or runData.deck.type ~= \"Deck\") then\r\n\t\tPlayer[player_clicker_color].broadcast(\"Could not find deck (must be deck of cards)\")\r\n\t\treturn\r\n\tend\r\n\t\r\n\trunData.cards = {}\r\n\tfor i, card in ipairs(runData.deck.getObjects()) do -- i starts at 1\r\n\t\t--if (skipGuids ~= true and card.guid == \"\") then\r\n\t\t--\tPlayer[player_clicker_color].broadcast(\"Freshly loaded deck detected. Loading card GUIDs.\")\r\n\t\t--\trunData.deck.spread(0.0000000001)\r\n\t\t--\tPlayer[player_clicker_color].broadcast(\"Complete. Please run your operation again.\")\r\n\t\t--\treturn nil\r\n\t\t--end\r\n\t\ttable.insert(runData.cards, getCard(card))\r\n\t\trunData.cards[i].deckIndex = i\r\n\tend\r\n\t\r\n\trunData.size = runData.deck.getBoundsNormalized().size\r\n\t--print(\"x: \"..runData.size.x)\r\n\t--print(\"z: \"..runData.size.z)\r\n\t\r\n\treturn runData\r\nend\r\n\r\nfunction increaseDeckIndex(runDataCards, deckIndex)\r\n\tfor i, card in ipairs(runDataCards) do\r\n\t\tif (card.deckIndex > deckIndex) then\r\n\t\t\tcard.deckIndex = card.deckIndex - 1\r\n\t\tend\r\n\tend\r\nend\r\n\r\nfunction layoutCards(obj, player_clicker_color, alt_click)\r\n\t\r\n\tlocal runData = getRunData(player_clicker_color)\r\n\tif (runData == nil) then return end\r\n\t\r\n\tfunction layout_routine()\r\n\t\r\n\t\tif (alt_click) then\r\n\t\t\trunData.rot[3] = runData.rot[3] + 180\r\n\t\tend\r\n\t\tlocal xOffset = xInitialOffset - runData.size.x/2\r\n\t\tlocal zOffset = 0\r\n\t\t\r\n\t\tlocal LayoutCount = -1\r\n\t\tif ( layoutData.cols ~= nil and layoutData.cols > 0 and layoutData.rows ~= nil and layoutData.rows > 0 ) then\r\n\t\t\tLayoutCount = layoutData.cols * layoutData.rows + 1\r\n\t\tend\r\n\t\t\r\n\t\tlocal columnCount = layoutData.cols\r\n\t\tif (columnCount == nil or columnCount == 0) then\r\n\t\t\tif (layoutData.rows == nil or layoutData.rows == 0) then\r\n\t\t\t\tcolumnCount = -1\r\n\t\t\telse\r\n\t\t\t\tcolumnCount = math.ceil(#runData.cards/layoutData.rows)\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tfor i,card in ipairs(runData.cards) do\r\n\t\t\t\r\n\t\t\tif (i == LayoutCount) then break end\r\n\t\t\t\r\n\t\t\tlocal endPosition = rotateAroundPoint(runData.pos, {runData.pos.x+(xOffset*xDirection), runData.pos.y+3, runData.pos.z+zOffset}, runData.rot[2] )\r\n\t\t\t\r\n\t\t\tif (i == #runData.cards) then\r\n\t\t\t\t-- Depricated: using the last object's GUID does not work on newly spawned decks\r\n\t\t\t\t\t-- now works since other things weren't working so GUID must be set\r\n\t\t\t\t\r\n\t\t\t\tlocal lastCard = getContainer(runData.pos)\r\n\t\t\t\t--local lastCard = getObjectFromGUID(runData.cards[i].guid)\r\n\t\t\t\t\r\n\t\t\t\tlastCard.setPosition( endPosition )\r\n\t\t\t\tlastCard.setRotation( runData.rot )\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\trunData.deck.takeObject({\r\n                index = 1,\r\n\t\t\t\tposition = endPosition,\r\n\t\t\t\trotation = runData.rot,\r\n                smooth = false,\r\n                --guid = runData.cards[i].guid,\r\n            })\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif (columnCount ~= -1 and i%columnCount == 0) then\r\n\t\t\t\tzOffset = zOffset + zIncrementOffset + runData.size.z\r\n\t\t\t\txOffset = xInitialOffset - runData.size.x/2\r\n\t\t\telse\r\n\t\t\t\txOffset = xOffset + xIncrementOffset - runData.size.x\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tcoroutine.yield(0)\r\n\t\tend\r\n\t\treturn 1\r\n\tend\r\n    startLuaCoroutine(self, \"layout_routine\")\r\n\t\r\nend\r\n\r\nfunction listCards(obj, player_clicker_color, alt_click)\r\n\t\r\n\tlocal runData = getRunData(player_clicker_color, true)\r\n\tif (runData == nil) then return end\r\n\t\r\n\tlocal list = ''\r\n    for _,card in pairs(runData.cards)do\r\n\t\t--local name = v.nickname:gsub('[\\n].*','')\r\n\t\tlist = list..'1 '..card.name..'\\n'\r\n    end\r\n\t\r\n\t-- remove any notebook tabs with name and color of player_clicker_color\r\n    local tabs = getNotebookTabs()\r\n\tfor i,tab in pairs(tabs) do\r\n\t\tif (tab.color == player_clicker_color and tab.title == player_clicker_color) then\r\n\t\t\tremoveNotebookTab(tab.index)\r\n\t\tend\r\n    end\r\n\t\r\n\taddNotebookTab({title=player_clicker_color , body=list , color=player_clicker_color})\r\n\tPlayer[player_clicker_color].broadcast('Deck list in Notebook Tab: '..player_clicker_color..'\\n'..\r\n\t\t\t\t\t\t 'Type [b][i]scryfall deck[/i][/b] into chat to re-import deck')\r\n\t\r\nend\r\n\r\nfunction alphabetize(obj, player_clicker_color, alt_click)\r\n\t\r\n\tlocal runData = getRunData(player_clicker_color)\r\n\tif (runData == nil) then return end\r\n\t\r\n    local pointA_ = {runData.pos.x+(xInitialOffset - runData.size.x/2)*xDirection, runData.pos.y, runData.pos.z}\r\n    local holdPointA_ = {runData.pos.x+(xInitialOffset - runData.size.x/2)*xDirection, runData.pos.y+3, runData.pos.z}\r\n\t\r\n\t-- Sort the cards\r\n\tsortBy_name(runData.cards)\r\n\t\r\n\t--print(pointA_[1]..\" - \"..pointA_[3])\r\n\t--print(rotateAroundPoint(_pos,pointA_,self.getRotation()[2])[1]..\" - \"..rotateAroundPoint(_pos,pointA_,self.getRotation()[2])[3])\r\n\t\r\n\t-- Place the sorted cards in a deck\r\n\tmoveToOutput(runData.deck, runData.cards, rotateAroundPoint(runData.pos,pointA_,self.getRotation()[2]), rotateAroundPoint(runData.pos,holdPointA_,self.getRotation()[2]), #runData.cards, nil, runData)\r\nend\r\n\r\nfunction sortByScroll(obj, player_clicker_color, alt_click)\r\n\tif (layoutData.sortBy == nil) then layoutData.sortBy = 1 end\r\n\t\r\n\tif (alt_click) then\r\n\t\tlayoutData.sortBy = layoutData.sortBy - 1\r\n\telse \r\n\t\tlayoutData.sortBy = layoutData.sortBy + 1\r\n\tend\r\n\t\r\n\t\r\n\tif (layoutData.sortBy > #sortByStrings) then\r\n\t\tlayoutData.sortBy = 1\r\n\telseif (layoutData.sortBy < 1) then\r\n\t\tlayoutData.sortBy = #sortByStrings\r\n\tend\r\n\t\r\n\tself.editButton({index=7,label=sortByStrings[layoutData.sortBy]})\r\nend\r\n\r\nfunction getStandardGroups()\r\n\tlocal groups = {}\r\n\tgroups['Creature'] = {}\r\n\tgroups['Instant'] = {}\r\n\tgroups['Sorcery'] = {}\r\n\tgroups['Enchantment'] = {}\r\n\tgroups['Artifact'] = {}\r\n\tgroups['Basic Land'] = {}\r\n\tgroups['Land'] = {}\r\n\tgroups['Planeswalker'] = {}\r\n\tgroups['Groupless'] = {}\r\n\treturn groups\r\nend\r\n\r\nfunction sortByType(obj, player_clicker_color, alt_click) -- alt click = nothing currently\r\n\r\n\tlocal runData = getRunData(player_clicker_color)\r\n\tif (runData == nil) then return end\r\n\t\r\n\t--print(\"found \"..#runData.cards..\" cards\")\r\n\t\r\n\tlocal _pos = runData.pos\r\n\t\r\n\tlocal sortedCards = {}\r\n\t\r\n\tif (layoutData.sortBy < 3) then\r\n\t\tsortedCards = getStandardGroups()\r\n\t\t\t\r\n\t\tif (layoutData.sortBy == 2) then\r\n\t\t\tsortedCards['Groupless'][''] = {}\r\n\t\tend\r\n\r\n\t\tfor i,c in ipairs(runData.cards) do\r\n\t\t\tif (c.type ~= '') then\r\n\t\t\t\tlocal no_group = true\r\n\t\t\t\tfor k,_ in pairs(sortedCards) do\r\n\t\t\t\t\tif c.type:match(k) then \r\n\t\t\t\t\t\taddToGroup(sortedCards, c, k, layoutData.sortBy == 2)\r\n\t\t\t\t\t\tno_group = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif no_group then\r\n\t\t\t\t\taddToGroup(sortedCards, c, 'Groupless', layoutData.sortBy == 2)\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\taddToGroup(sortedCards, c, 'Groupless', layoutData.sortBy == 2)\r\n\t\t\tend\r\n\t\tend\r\n\telseif (layoutData.sortBy == 3) then\r\n\t\t\r\n\t\tfor i = 0, 100 do\r\n\t\t\tsortedCards[tostring(i)] = {}\r\n\t\tend\r\n\t\r\n\t\tfor _,c in ipairs(runData.cards) do\r\n\t\t\tif (c.cmc ~= nil) then\r\n\t\t\t\tlocal no_group = true\r\n\t\t\t\tfor k,_ in pairs(sortedCards) do\r\n\t\t\t\t\tif c.cmc == k then \r\n\t\t\t\t\t\taddToGroup(sortedCards, c, k, layoutData.sortBy == 2)\r\n\t\t\t\t\t\tno_group = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif no_group then\r\n\t\t\t\t\taddToGroup(sortedCards, c, c.cmc, layoutData.sortBy == 2)\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\taddToGroup(sortedCards, c, 'Groupless', layoutData.sortBy == 2)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\t\r\n\tmoveSortedCardsToOutput(sortByData[layoutData.sortBy].dimensions, sortedCards, _pos, runData)\r\nend\r\n\r\nfunction findByText(obj, player_clicker_color, alt_click)\r\n\tlocal runData = getRunData(player_clicker_color)\r\n\tif (runData == nil) then return end\r\n\t\r\n    local pointA_ = {runData.pos.x+(xInitialOffset - runData.size.x/2)*xDirection, runData.pos.y, runData.pos.z}\r\n\t\r\n\tfunction find_routine()\r\n\t\t\r\n\t\tlocal noneFound = true\r\n\t\tif (alt_click) then\r\n\t\t\trunData.rot[3] = runData.rot[3] + 180\r\n\t\tend\r\n\t\r\n\t\tfor i, card in pairs(runData.cards)do\r\n\t\t\tif (string.lower(card.fullName):match(string.lower(searchText)) or \r\n\t\t\t\tstring.lower(card.description):match(string.lower(searchText))\r\n\t\t\t\t) then\r\n\t\t\t\tnoneFound = false\r\n\t\t\t\t--print(card.name)\r\n\t\t\t\tincreaseDeckIndex(runData.cards, runData.cards[i].deckIndex)\r\n\t\t\t\trunData.deck.takeObject({\r\n\t\t\t\t\tindex=runData.cards[i].deckIndex-1,\r\n\t\t\t\t\tposition = rotateAroundPoint(runData.pos,pointA_,self.getRotation()[2]),\r\n\t\t\t\t\trotation = runData.rot,\r\n\t\t\t\t\tsmooth = false,\r\n\t\t\t\t\t--guid = runData.cards[i].guid,\r\n\t\t\t\t})\r\n\t\t\t\tcoroutine.yield(0)\r\n\t\t\tend\r\n\t\tend\r\n\t\r\n\t\tif (noneFound) then\r\n\t\t\tprintToColor(\"No cards with text found\",player_clicker_color)\r\n\t\tend\r\n\t\treturn 1\r\n\tend\r\n    startLuaCoroutine(self, \"find_routine\")\r\n\t\r\n\t\r\nend\r\n\r\nfunction addToGroup(groups, card, group, useSubType)\r\n\tif (groups[group] == nil) then\r\n\t\tgroups[group] = {}\r\n\tend\r\n\r\n\t--print(\"added group: \"..group)\r\n\r\n\tif (useSubType) then\r\n\t\tif (groups[group][card.type] == nil) then\r\n\t\t\tgroups[group][card.type] = {}\r\n\t\tend\r\n\t\ttable.insert(groups[group][card.type], card)\r\n\telse\r\n\t\ttable.insert(groups[group], card)\r\n\tend\r\nend\r\n\r\nfunction moveSortedCardsToOutput(dimentions, sortedCards, _pos, runData)\r\n\r\n\tlocal cardObjectGroups = {}\r\n\r\n\tlocal yRotation = runData.rot[2]\r\n\tlocal x_offset = xInitialOffset - runData.size.x/2\r\n\tif (dimentions == 2) then\r\n\t\tfor k,subTypeGroups in pairs(sortedCards) do\r\n\t\t\tlocal zOffset = 0\r\n\t\t\tlocal zOffsetCount = 0\r\n\t\t\tlocal didAny = false\r\n\t\t\tcardObjectGroups[#cardObjectGroups+1] = {}\r\n\t\t\tfor l,cardsInGroup in pairs(subTypeGroups) do\r\n\t\t\t\tif #cardsInGroup ~= 0 then\r\n\t\t\t\t\tcardObjectGroups[#cardObjectGroups][#cardObjectGroups[#cardObjectGroups]+1] = {}\r\n\t\t\t\t\r\n\t\t\t\t\tdidAny = true\r\n\t\t\t\t\tlocal sortedCardsInGroup = cardsInGroup\r\n\t\t\t\t\tsortBy_name(sortedCardsInGroup)\r\n\t\t\t\t\tlocal destPoint = rotateAroundPoint(_pos,{_pos.x+x_offset*xDirection, _pos.y, _pos.z+zOffset},yRotation)\r\n\t\t\t\t\t--local holdPoint = rotateAroundPoint(_pos,{_pos.x+x_offset*xDirection, _pos.y+3, _pos.z+zOffset},yRotation)\r\n\t\t\t\t\t\r\n\t\t\t\t\tcardObjectGroups[#cardObjectGroups][#cardObjectGroups[#cardObjectGroups]].cards = sortedCardsInGroup\r\n\t\t\t\t\tcardObjectGroups[#cardObjectGroups][#cardObjectGroups[#cardObjectGroups]].dest = destPoint\r\n\t\t\t\t\t\r\n\t\t\t\t\t--moveToOutput(runData.deck, sortedCardsInGroup, destPoint, holdPoint, #cardsInGroup, nil, runData)\r\n\t\t\t\t\tzOffset = zOffset + zIncrementOffset + runData.size.z\r\n\t\t\t\t\tzOffsetCount = zOffsetCount + 1\r\n\t\t\t\t\tif (zOffsetCount >= maxZOffset) then\r\n\t\t\t\t\t\tx_offset = x_offset + xIncrementOffset - runData.size.x\r\n\t\t\t\t\t\tzOffset = 0\r\n\t\t\t\t\t\tzOffsetCount = 0\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tif (didAny) then\r\n\t\t\t\tx_offset = x_offset + xIncrementOffset - runData.size.x\r\n\t\t\tend\r\n\t\tend\r\n\telse\r\n\t\tfor k,cardsInGroup in pairs(sortedCards) do\r\n\t\t\tif #cardsInGroup ~= 0 then\r\n\t\t\t\tcardObjectGroups[#cardObjectGroups+1] = {}\r\n\t\t\t\t\r\n\t\t\t\tlocal sortedCardsInGroup = cardsInGroup\r\n\t\t\t\tsortBy_name(sortedCardsInGroup)\r\n\t\t\t\tlocal destPoint = rotateAroundPoint(_pos,{_pos.x+x_offset*xDirection, _pos.y, _pos.z},yRotation)\r\n\t\t\t\t--local holdPoint = rotateAroundPoint(_pos,{_pos.x+x_offset*xDirection, _pos.y+3, _pos.z},yRotation)\r\n\t\t\t\t\r\n\t\t\t\tcardObjectGroups[#cardObjectGroups].cards = sortedCardsInGroup\r\n\t\t\t\tcardObjectGroups[#cardObjectGroups].dest = destPoint\r\n\t\t\t\t\r\n\t\t\t\t--moveToOutput(runData.deck, c, destPoint, holdPoint, #cardsInGroup, nil, runData)\r\n\t\t\t\tx_offset = x_offset + xIncrementOffset - runData.size.x\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\t\r\n\tmoveGroupsToOutput(runData, cardObjectGroups)\r\nend\r\n\r\nfunction getCurrentCardObjectGroup(cardObjectGroups)\r\n\tif (cardObjectGroups.cards ~= nil) then\r\n\t\treturn cardObjectGroups \r\n\tend\r\n\t\r\n\twhile (true) do\r\n\t\tif (cardObjectGroups[1] == nil) then return nil end\r\n\t\tlocal cardObjectGroup = getCurrentCardObjectGroup(cardObjectGroups[1])\r\n\t\t\r\n\t\tif (cardObjectGroup == nil) then\r\n\t\t\tif (cardObjectGroups[1] ~= nil) then\r\n\t\t\t\ttable.remove(cardObjectGroups,1)\r\n\t\t\tend\r\n\t\telseif (cardObjectGroup.cards ~= nil and #(cardObjectGroup.cards) == 0) then\r\n\t\t\ttable.remove(cardObjectGroups,1)\r\n\t\telse\r\n\t\t\treturn cardObjectGroup\r\n\t\tend\r\n\tend\r\nend\r\n\r\nfunction moveGroupsToOutput(runData, cardObjectGroups)\r\n\t\r\n\tlocal cardObjectGroup = getCurrentCardObjectGroup(cardObjectGroups)\r\n\tif (cardObjectGroup == nil) then return end\r\n\t\r\n\t-- reaching here means it has a non-empty set of card(s)\r\n\t\r\n\tlocal dest = getContainer(cardObjectGroup.dest)\r\n\tlocal holdPoint = {cardObjectGroup.dest[1], cardObjectGroup.dest[2]+5, cardObjectGroup.dest[3]}\r\n\t\r\n\tif runData ~= nil and runData.deck == nil then\r\n\t\t--print(\"finding last card\")\r\n\t\t--local lastCard = getObjectFromGUID(cards[index].guid)\r\n\t\tlocal lastCard = getContainer(runData.pos)\r\n\t\t\r\n\t\tif (lastCard ~= nil) then\r\n\t\t\tif dest == nil then\r\n\t\t\t\tlastCard.setPosition( cardObjectGroup.dest )\r\n\t\t\telse\r\n\t\t\t\tlastCard.setPosition( holdPoint )\r\n\t\t\t\tdest.putObject(lastCard)\r\n\t\t\tend\r\n\t\tend\r\n\t\treturn\r\n\tend\r\n\t\r\n\tif runData.deck.type == \"Deck\" then\r\n\t\tincreaseDeckIndex(runData.cards, cardObjectGroup.cards[1].deckIndex)\r\n        if dest == nil then\r\n            runData.deck.takeObject({\r\n\t\t\t\tindex=cardObjectGroup.cards[1].deckIndex-1,-- Index starts at 0\r\n                position = holdPoint,\r\n                callback_function = function(card)\r\n                    card.setPosition(cardObjectGroup.dest)\r\n\t\t\t\t\ttable.remove(cardObjectGroup.cards,1)\r\n                    Wait.time(function()\r\n                        moveGroupsToOutput(runData, cardObjectGroups)\r\n                    end, timeDelay)\r\n                end,\r\n                smooth = false,\r\n            })\r\n            return\r\n        end\r\n        runData.deck.takeObject({\r\n\t\t\tindex=cardObjectGroup.cards[1].deckIndex-1,-- Index starts at 0\r\n            position = holdPoint,\r\n            callback_function = function(card)\r\n                dest.putObject(card)\r\n\t\t\t\ttable.remove(cardObjectGroup.cards,1)\r\n                Wait.time(function()\r\n                    moveGroupsToOutput(runData, cardObjectGroups)\r\n                end, timeDelay)\r\n            end,\r\n            smooth = false,\r\n        })\r\n    end\r\n\t\r\nend\r\n\r\n    \r\nfunction moveToOutput(source, cards, destPoint, holdPoint, limit, index, runData)\r\n    if limit == 0 then return end\r\n    -- Get containers at points\r\n    local dest = getContainer(destPoint)\r\n\r\n    if source == nil and runData ~= nil then\r\n\t\r\n\t\t--print(\"finding last card\")\r\n\t\t--local lastCard = getObjectFromGUID(cards[index].guid)\r\n\t\tlocal lastCard = getContainer(runData.pos)\r\n\t\t\r\n\t\tif (lastCard ~= nil) then\r\n\t\t\tif dest == nil then\r\n\t\t\t\tlastCard.setPosition( destPoint )\r\n\t\t\telse\r\n\t\t\t\tlastCard.setPosition( holdPoint )\r\n\t\t\t\tdest.putObject(lastCard)\r\n\t\t\tend\r\n\t\tend\r\n\t\treturn\r\n\tend\r\n\r\n    if source.type == \"Deck\" then\r\n        if index == nil then index = 1 end\r\n\t\t--print(cards[index].name..\" from \"..tostring(cards[index].deckIndex-1))\r\n        if dest == nil then\r\n\t\t\tincreaseDeckIndex(cards, cards[index].deckIndex)\r\n            source.takeObject({\r\n\t\t\t\tindex=cards[index].deckIndex-1,-- Index starts at 0\r\n                position = holdPoint,\r\n                callback_function = function(card)\r\n                    card.setPosition(destPoint)\r\n                    Wait.time(function()\r\n                        moveToOutput(source, cards, destPoint, holdPoint, limit-1, index+1, runData)\r\n                    end, timeDelay)\r\n                end,\r\n                smooth = false,\r\n                --guid = cards[index].guid,\r\n            })\r\n            return\r\n        end\r\n\t\tincreaseDeckIndex(cards, cards[index].deckIndex)\r\n        source.takeObject({\r\n\t\t\tindex=cards[index].deckIndex-1,-- Index starts at 0\r\n            position = holdPoint,\r\n            callback_function = function(card)\r\n                dest.putObject(card)\r\n                Wait.time(function()\r\n                    moveToOutput(source, cards, destPoint, holdPoint, limit-1, index+1, runData)\r\n                end, timeDelay)\r\n            end,\r\n            smooth = false,\r\n            --guid = cards[index].guid,\r\n        })\r\n    end\r\nend\r\n\r\nfunction getContainer(pos)\r\n    local hits = Physics.cast({\r\n        origin = pos,\r\n        direction = {0,1,0},\r\n        size = {1,2,1},\r\n        type = 2,\r\n        max_distance = 0.1,\r\n\t\t--debug=true,\r\n    })\r\n    for _,o in ipairs(hits) do\r\n        if o.hit_object.type == \"Deck\" or o.hit_object.type == \"Card\" then\r\n            return o.hit_object\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\nfunction sortBy_name(deck)\r\n    table.sort(deck, function(_str, _val)\r\n        if (_str == nil and _val == nil) then return true end\r\n        if (_str == nil and _val ~= nil) then return false end\r\n        if (_str ~= nil and _val == nil) then return true end\r\n\r\n        str = _str.name:lower()\r\n        val = _val.name:lower()\r\n        limit = math.min(#str, #val)\r\n\r\n        for i=1, limit do\r\n            if str:sub(i,i) > val:sub(i,i) then\r\n                return false\r\n            elseif str:sub(i,i) < val:sub(i,i) then\r\n                return true\r\n            end\r\n        end\r\n        \r\n        return false\r\n    end)\r\nend\r\n\r\nfunction getCard(c)\r\n    local card = {}\r\n\r\n    card.guid = c.guid\r\n\tcard.fullName = c.name\r\n    \r\n    local parts = c.name:split('\\n')\r\n    card.name = parts[1]\r\n\tif (#parts >= 3) then\r\n\t\tcard.cmc = parts[3]:split(' ')[1]\r\n\tend\r\n    card.type = ''\r\n    if #parts >= 2 then\r\n        card.type = parts[2]--:gsub('%s.*', '') \r\n    end\r\n\tcard.description = c.description\r\n\r\n    return card\r\nend\r\n\r\n\r\n--- OnChat Activation of previous functions ---\r\n\r\nfunction setCommandList()\r\n\tcommands = {}\r\n\tcommands[\"!test\"] = \t{\"!test\",\t\t\"broadcastTest\", \t\t0,\t\"No arguments\", \t\t\"Confirms the existance of the item\"}\r\n\t\r\n\t\r\n\t\r\n\tcommands[\"!test\"] = \t{\"!test\",\t\t\"broadcastTest\", \t\t0,\t\"No arguments\", \t\t\"Confirms the existance of the item\"}\r\n\t\r\n\t---help must be offset due to programming in onChat\r\n\t--commands[\"!help\"] = \t{\"!help\", \"broadcastHelp\", 0, \t\t\"<optional: command>\", \r\n\t--\t\"Gets the description of a command or a general help statement\"}\r\nend\r\n\r\nfunction broadcastTest(tempParameters) broadcastOrPrint(tempParameters.theChatter, mod_name..\" currently on the table.\", true) end\r\n\r\nfunction onChat(message, theChatter)\r\n\tif (commands == nil) then setCommandList() end\r\n\r\n\tlocal args = {} -- The arguments following a command\r\n\tlocal command = nil -- The command. \"move\" etc\r\n\tfor i in string.gmatch(message, \"%S+\") do\r\n\t\tif(command == nil) then\r\n\t\t\tcommand = string.lower(i)\r\n\t\telse\r\n\t\t\targs[#args + 1] = i\r\n\t\tend\r\n\tend\r\n\t\r\n\tfor commandKey, value in pairs(commands) do\r\n\t\t\tif command == \"!help\" and args[1] == commandKey then\r\n\t\t\t\ttheChatter.broadcast(announceColour..commands[commandKey][1]..\", \"..commands[commandKey][3]..\": \"..commands[commandKey][5])\r\n\t\t\t\ttheChatter.broadcast(announceColour..\"Usage: \"..commandKey..\" \"..commands[commandKey][4])\r\n\t\t\t\treturn false\r\n\t\t\t--[[elseif #args > 0 and command == \"!help\" and commandKey == \"!help\" then\r\n\t\t\t\t--theChatter.broadcast(announceColour..\"help: unknown command\")\r\n\t\t\t\treturn false\r\n\t\t\t\t\r\n\t\t\telseif command == commandKey then\r\n\t\t\t\tif checkPermission(theChatter,commands[commandKey][3]) then\r\n\t\t\t\t\ttempParameters = {theChatter=theChatter,args=args}\r\n\t\t\t\t\t--tempParameters.theChatter = theChatter\r\n\t\t\t\t\t--tempParameters.args = args\r\n\t\t\t\t\tself.call(commands[commandKey][2], tempParameters)\r\n\t\t\t\telse\r\n\t\t\t\t\ttheChatter.broadcast(announceColour..\"You don't have permission to do that.\")\r\n\t\t\t\tend\r\n\t\t\t\treturn false]]--\r\n\t\t\tend\r\n\t\tend\r\n\t\r\n\t\r\n\t\r\n\tif (command == \"!roll\") then\r\n\t\tprint(\"roll: \"..args[1])\r\n\t\t\r\n\t\treturn false\r\n\tend\r\nend\r\n",
      "LuaScriptState": "{\"cols\":12,\"rows\":7,\"sortBy\":1}",
      "XmlUI": ""
    }
  ]
}